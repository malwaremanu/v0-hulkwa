var __defProp = Object.defineProperty, __typeError = e => { throw TypeError(e) }, __defNormalProp = (e, t, i) => t in e ? __defProp(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, __publicField = (e, t, i) => __defNormalProp(e, "symbol" != typeof t ? t + "" : t, i), __accessCheck = (e, t, i) => t.has(e) || __typeError("Cannot " + i), __privateGet = (e, t, i) => (__accessCheck(e, t, "read from private field"), i ? i.call(e) : t.get(e)), __privateAdd = (e, t, i) => t.has(e) ? __typeError("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, i), __privateSet = (e, t, i, a) => (__accessCheck(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i), __privateWrapper = (e, t, i, a) => ({ set _(a) { __privateSet(e, t, a, i) }, get _() { return __privateGet(e, t, a) } }); !function () { "use strict"; var e, t, i; const a = "https://backend.sheetwa.com", n = class e { constructor() { __publicField(this, "_debugMode", !1) } static getInstance() { return e.instance || (e.instance = new e), e.instance } get debugMode() { return this._debugMode } set debugMode(e) { this._debugMode = e } }; __publicField(n, "instance"); let o = n; const s = async function (e) { return await chrome.storage.local.get(e) }; function r(e) { return chrome.runtime.sendMessage(chrome.runtime.id, e) } let d = []; function c(...e) { const t = o.getInstance(); if (self.showLogs && console.log(...e), t.debugMode && (d.push(e), d.length >= 5)) try { ve.post(`${a}/save-error-logs`, { token: !0, data: { message: d } }), d = [] } catch (i) { console.log("error in log", i) } } class l { constructor() { __privateAdd(this, e, {}), __privateAdd(this, t, {}) } emit(i, ...a) { var n; for (__privateGet(this, e)[i] && __privateGet(this, e)[i].forEach((e => { e(...a) })); null == (n = __privateGet(this, t)[i]) ? void 0 : n.length;) { const e = __privateGet(this, t)[i].shift(); e && e(...a) } } on(t, i) { __privateGet(this, e)[t] ? __privateGet(this, e)[t].push(i) : __privateGet(this, e)[t] = [i] } once(e, i) { __privateGet(this, t)[e] ? __privateGet(this, t)[e].push(i) : __privateGet(this, t)[e] = [i] } } e = new WeakMap, t = new WeakMap; const u = { Page: { evaluate: async (e, ...t) => await e(...t), waitForFunction: async (e, { timeout: t } = { timeout: 0 }) => new Promise(((i, a) => { const n = setInterval((() => { e() && (clearInterval(n), i()) }), 500); t && setTimeout((() => { clearInterval(n), e() ? i() : a() }), t) })), waitForSelector: async (e, { timeout: t }) => new Promise(((i, a) => { const n = new MutationObserver(((t, a) => { document.querySelector(e) && (n.disconnect(), i()) })); n.observe(document, { childList: !0, attributes: !0, subtree: !0 }); document.querySelector(e) && (n.disconnect(), i()), t && setTimeout((() => { n.disconnect(), a("timeout") }), t) })), exposeFunction: async (e, t) => { window[e] = t } } }; function w(e) { for (var t = "", i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", a = 0; a < e; a++)t += i.charAt(Math.floor(62 * Math.random())); return t } function p(e, t) { return e = Number(String(e).replace(/\D/g, "")), t = Number(String(t).replace(/\D/g, "")), { number: e = e ? String(e) : "", countryCode: t = t ? String(t) : "", fullNumber: `${t}${e}` } } class h { constructor(e) { this.pupPage = e.pupPage } async openChatWindow(e) { await this.pupPage.evaluate((async e => { let t = window.SWA_Store.WidFactory.createWid(e), i = await window.SWA_Store.Chat.find(t); await window.SWA_Store.Cmd.openChatAt(i) }), e) } async openChatDrawer(e) { await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Chat.get(e); await window.SWA_Store.Cmd.openDrawerMid(t) }), e) } async openChatSearch(e) { await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Chat.get(e); await window.SWA_Store.Cmd.chatSearch(t) }), e) } async openChatWindowAt(e) { await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Msg.get(e), i = await window.SWA_Store.Chat.find(t.id.remote), a = await window.SWA_Store.SearchContext(i, t); await window.SWA_Store.Cmd.openChatAt(i, a) }), e) } async openMessageDrawer(e) { await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Msg.get(e); await window.SWA_Store.Cmd.msgInfoDrawer(t) }), e) } async getFeatures() { return await this.pupPage.evaluate((() => { if (!window.SWA_Store.Features) throw new Error("This version of Whatsapp Web does not support features"); return window.SWA_Store.Features.F })) } async checkFeatureStatus(e) { return await this.pupPage.evaluate((e => { if (!window.SWA_Store.Features) throw new Error("This version of Whatsapp Web does not support features"); return window.SWA_Store.Features.supportsFeature(e) }), e) } async enableFeatures(e) { await this.pupPage.evaluate((e => { if (!window.SWA_Store.Features) throw new Error("This version of Whatsapp Web does not support features"); for (const t in e) window.SWA_Store.Features.setFeature(e[t], !0) }), e) } async disableFeatures(e) { await this.pupPage.evaluate((e => { if (!window.SWA_Store.Features) throw new Error("This version of Whatsapp Web does not support features"); for (const t in e) window.SWA_Store.Features.setFeature(e[t], !1) }), e) } } const m = { puppeteer: { headless: !0, defaultViewport: null }, webVersion: "2.2346.52", webVersionCache: { type: "local" }, authTimeoutMs: 0, qrMaxRetries: 0, takeoverOnConflict: !1, takeoverTimeoutMs: 0, userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67 Safari/537.36", ffmpegPath: "ffmpeg", bypassCSP: !1, proxyAuthentication: void 0 }, S = "ready", g = "chat_removed", y = "chat_archived", W = "message", _ = "message_ciphertext", A = "message_create", f = "message_revoke_everyone", b = "message_revoke_me", v = "message_ack", C = "message_edit", M = "unread_count", P = "message_reaction", k = "media_uploaded", I = "contact_changed", E = "group_join", F = "group_leave", L = "group_admin_changed", J = "group_membership_request", q = "group_update", N = "loading_screen", x = "disconnected", z = "change_state", T = "location", U = "vcard", O = "multi_vcard", D = "order", B = "groups_v4_invite", R = "payment", G = "poll_creation", V = "CONFLICT", j = "CONNECTED", K = "OPENING", H = "PAIRING", Q = "TIMEOUT"; function $() { window.SWA_AuthStore = {}, window.SWA_AuthStore.AppState = window.require("WAWebSocketModel").Socket, window.SWA_AuthStore.Cmd = window.require("WAWebCmd").Cmd, window.SWA_AuthStore.Conn = window.require("WAWebConnModel").Conn, window.SWA_AuthStore.OfflineMessageHandler = window.require("WAWebOfflineHandler").OfflineMessageHandler, window.SWA_AuthStore.PairingCodeLinkUtils = window.require("WAWebAltDeviceLinkingApi"), window.SWA_AuthStore.Base64Tools = window.require("WABase64"), window.SWA_AuthStore.RegistrationUtils = { ...window.require("WAWebCompanionRegClientUtils"), ...window.require("WAWebAdvSignatureApi"), ...window.require("WAWebUserPrefsInfoStore"), ...window.require("WAWebSignalStoreApi") } } function X() { window.SWA_Store = Object.assign({}, window.require("WAWebCollections")), window.SWA_Store.AppState = window.require("WAWebSocketModel").Socket, window.SWA_Store.Conn = window.require("WAWebConnModel").Conn, window.SWA_Store.Cmd = window.require("WAWebCmd").Cmd, window.SWA_Store.MediaPrep = window.require("WAWebPrepRawMedia"), window.SWA_Store.MediaObject = window.require("WAWebMediaStorage"), window.SWA_Store.MediaTypes = window.require("WAWebMmsMediaTypes"), window.SWA_Store.MediaUpload = window.require("WAWebMediaMmsV4Upload"), window.SWA_Store.MsgKey = window.require("WAWebMsgKey"), window.SWA_Store.NumberInfo = window.require("WAPhoneUtils"), window.SWA_Store.PhoneFindCC = window.require("WAPhoneFindCC"), window.SWA_Store.OpaqueData = window.require("WAWebMediaOpaqueData"), window.SWA_Store.SendMessage = window.require("WAWebSendMsgChatAction"), window.SWA_Store.EditMessage = window.require("WAWebSendMessageEditAction"), window.SWA_Store.SendSeen = window.require("WAWebUpdateUnreadChatAction"), window.SWA_Store.User = window.require("WAWebUserPrefsMeUser"), window.SWA_Store.ContactMethods = window.require("WAWebContactGetters"), window.SWA_Store.UploadUtils = window.require("WAWebUploadManager"), window.SWA_Store.UserConstructor = window.require("WAWebWid"), window.SWA_Store.Validators = window.require("WALinkify"), window.SWA_Store.VCard = window.require("WAWebFrontendVcardUtils"), window.SWA_Store.WidFactory = window.require("WAWebWidFactory"), window.SWA_Store.ChatState = window.require("WAWebChatStateBridge"), window.SWA_Store.findCommonGroups = window.require("WAWebFindCommonGroupsContactAction").findCommonGroups, window.SWA_Store.ConversationMsgs = window.require("WAWebChatLoadMessages"), window.SWA_Store.createOrUpdateReactionsModule = window.require("WAWebDBCreateOrUpdateReactions"), window.SWA_Store.EphemeralFields = window.require("WAWebGetEphemeralFieldsMsgActionsUtils"), window.SWA_Store.MsgActionChecks = window.require("WAWebMsgActionCapability"), window.SWA_Store.QuotedMsg = window.require("WAWebQuotedMsgModelUtils"), window.SWA_Store.LinkPreview = window.require("WAWebLinkPreviewChatAction"), window.SWA_Store.SearchContext = window.require("WAWebChatMessageSearch").getSearchContext, window.SWA_Store.getMsgInfo = window.require("WAWebApiMessageInfoStore").queryMsgInfo, window.SWA_Store.QueryExist = window.require("WAWebQueryExistsJob").queryWidExists, window.SWA_Store.QueryExistJob = window.require("WAWebQueryExistsJob"), window.SWA_Store.PhoneNumberFormatUtils = window.require("WAWebLinkDevicePhoneNumberEntryInputFormatUtils"), window.SWA_Store.ReplyUtils = window.require("WAWebMsgReply"), window.SWA_Store.HistorySync = window.require("WAWebSendNonMessageDataRequest"), window.SWA_Store.Lid1X1MigrationGating = window.require("WAWebLid1X1MigrationGating"), window.SWA_Store.StickerTools = { ...window.require("WAWebImageUtils"), ...window.require("WAWebAddWebpMetadata") }, window.SWA_Store.GroupParticipants = { ...window.require("WAWebModifyParticipantsGroupAction"), ...window.require("WASmaxGroupsAddParticipantsRPC") }, window.SWA_Store.Chat._find && window.SWA_Store.Chat.findImpl || (window.SWA_Store.Chat._find = e => { const t = window.SWA_Store.Chat.get(e); return t ? Promise.resolve(t) : Promise.resolve({ id: e }) }, window.SWA_Store.Chat.findImpl = window.SWA_Store.Chat._find), window.injectToFunction = (e, t) => { const i = window.require(e.module), a = i[e.function]; i[e.function] = (...e) => t(a, ...e) }, window.injectToFunction({ module: "WAWebBackendJobsCommon", function: "mediaTypeFromProtobuf" }, ((e, ...t) => { const [i] = t; return i.locationMessage ? null : e(...t) })), window.injectToFunction({ module: "WAWebE2EProtoUtils", function: "typeAttributeFromProtobuf" }, ((e, ...t) => { const [i] = t; return i.locationMessage || i.groupInviteMessage ? "text" : e(...t) })) } function Y() { window.WWebJS = {}, window.WWebJS.sendSeen = async e => { let t = window.SWA_Store.Chat.get(e); return void 0 !== t && (await window.SWA_Store.SendSeen.sendSeen(t, !1), !0) }, window.WWebJS.sendMessage = async (e, t, i = {}) => { var a, n, o; let s = {}; i.attachment && (s = i.sendMediaAsSticker ? await window.WWebJS.processStickerData(i.attachment) : await window.WWebJS.processMediaData(i.attachment, { forceVoice: i.sendAudioAsVoice, forceDocument: i.sendMediaAsDocument, forceGif: i.sendVideoAsGif }), s.caption = i.caption, t = i.sendMediaAsSticker ? void 0 : s.preview, s.isViewOnce = i.isViewOnce, delete i.attachment, delete i.sendMediaAsSticker); let r = {}; if (i.quotedMessageId) { let t = window.SWA_Store.Msg.get(i.quotedMessageId); (window.SWA_Store.ReplyUtils ? window.SWA_Store.ReplyUtils.canReplyMsg(t.unsafe()) : t.canReply()) && (r = t.msgContextInfo(e)), delete i.quotedMessageId } i.mentionedJidList && (i.mentionedJidList = await Promise.all(i.mentionedJidList.map((async e => { const t = window.SWA_Store.WidFactory.createWid(e); if (await window.SWA_Store.QueryExist(t)) return t }))), i.mentionedJidList = i.mentionedJidList.filter(Boolean)), i.groupMentions && (i.groupMentions = i.groupMentions.map((e => ({ groupSubject: e.subject, groupJid: window.SWA_Store.WidFactory.createWid(e.id) })))); let d = {}; if (i.location) { let { latitude: e, longitude: t, description: o, url: s } = i.location; s = null == (n = null == (a = window.SWA_Store.Validators) ? void 0 : a.findLink(s)) ? void 0 : n.href, s && !o && (o = s), d = { type: "location", loc: o, lat: e, lng: t, clientUrl: s }, delete i.location } let c = {}; if (i.poll) { const { pollName: e, pollOptions: t } = i.poll, { allowMultipleAnswers: a, messageSecret: n } = i.poll.options; c = { type: "poll_creation", pollName: e, pollOptions: t, pollSelectableOptionsCount: a ? 0 : 1, messageSecret: Array.isArray(n) && 32 === n.length ? new Uint8Array(n) : window.crypto.getRandomValues(new Uint8Array(32)) }, delete i.poll } let l = {}; if (i.contactCard) { let e = window.SWA_Store.Contact.get(i.contactCard); l = { body: window.SWA_Store.VCard.vcardFromContactModel(e).vcard, type: "vcard", vcardFormattedName: e.formattedName }, delete i.contactCard } else if (i.contactCardList) { l = { type: "multi_vcard", vcardList: i.contactCardList.map((e => window.SWA_Store.Contact.get(e))).map((e => window.SWA_Store.VCard.vcardFromContactModel(e))), body: void 0 }, delete i.contactCardList } else if (i.parseVCards && "string" == typeof t && t.startsWith("BEGIN:VCARD")) { delete i.parseVCards; try { const e = window.SWA_Store.VCard.parseVcard(t); e && (l = { type: "vcard", vcardFormattedName: window.SWA_Store.VCard.vcardGetNameFromParsed(e) }) } catch (W) { } } if (i.linkPreview) { delete i.linkPreview; const e = null == (o = window.SWA_Store.Validators) ? void 0 : o.findLink(t); if (e) { let t = await window.SWA_Store.LinkPreview.getLinkPreview(e); t && t.data && (t = t.data, t.preview = !0, t.subtype = "url", i = { ...i, ...t }) } } let u = {}; if (i.buttons) { let e; e = "chat" === i.buttons.type ? t = i.buttons.body : i.caption ? i.caption : " ", u = { productHeaderImageRejected: !1, isFromTemplate: !1, isDynamicReplyButtonsMsg: !0, title: i.buttons.title ? i.buttons.title : void 0, footer: i.buttons.footer ? i.buttons.footer : void 0, dynamicReplyButtons: i.buttons.buttons, replyButtons: i.buttons.buttons, caption: e }, delete i.buttons } let w = {}; if (i.list) { if ("smba" === window.SWA_Store.Conn.platform || "smbi" === window.SWA_Store.Conn.platform) throw "[LT01] Whatsapp business can't send this yet"; w = { type: "list", footer: i.list.footer, list: { ...i.list, listType: 1 }, body: i.list.description }, delete i.list, delete w.list.footer } const p = window.SWA_Store.User.getMaybeMePnUser(), h = await window.SWA_Store.MsgKey.newId(), m = new window.SWA_Store.MsgKey({ from: p, to: e.id, id: h, participant: e.id.isGroup() ? p : void 0, selfDir: "out" }), S = i.extraOptions || {}; delete i.extraOptions; const g = window.SWA_Store.EphemeralFields.getEphemeralFields(e), y = { ...i, id: m, ack: 0, body: t, from: p, to: e.id, local: !0, self: "out", t: parseInt((new Date).getTime() / 1e3), isNewMsg: !0, type: "chat", ...g, ...d, ...c, ...s, ...s.toJSON ? s.toJSON() : {}, ...r, ...l, ...u, ...w, ...S }; return await window.SWA_Store.SendMessage.addAndSendMsgToChat(e, y), await window.SWA_Store.HistorySync.sendPeerDataOperationRequest(3, { chatId: e.id }), window.SWA_Store.Msg.get(m._serialized) }, window.WWebJS.editMessage = async (e, t, i = {}) => { var a; const n = i.extraOptions || {}; if (delete i.extraOptions, i.mentionedJidList && (i.mentionedJidList = await Promise.all(i.mentionedJidList.map((async e => { const t = window.SWA_Store.WidFactory.createWid(e); if (await window.SWA_Store.QueryExist(t)) return t }))), i.mentionedJidList = i.mentionedJidList.filter(Boolean)), i.groupMentions && (i.groupMentions = i.groupMentions.map((e => ({ groupSubject: e.subject, groupJid: window.SWA_Store.WidFactory.createWid(e.id) })))), i.linkPreview) { delete i.linkPreview; const e = null == (a = window.SWA_Store.Validators) ? void 0 : a.findLink(t); if (e) { const t = await window.SWA_Store.LinkPreview.getLinkPreview(e); t.preview = !0, t.subtype = "url", i = { ...i, ...t } } } const o = { ...i, ...n }; return await window.SWA_Store.EditMessage.sendMessageEdit(e, t, o), window.SWA_Store.Msg.get(e.id._serialized) }, window.WWebJS.toStickerData = async e => { if ("image/webp" == e.mimetype) return e; const t = window.WWebJS.mediaInfoToFile(e), i = await window.SWA_Store.StickerTools.toWebpSticker(t), a = await i.arrayBuffer(); return { mimetype: "image/webp", data: window.WWebJS.arrayBufferToBase64(a) } }, window.WWebJS.processStickerData = async e => { if ("image/webp" !== e.mimetype) throw new Error("Invalid media type"); const t = window.WWebJS.mediaInfoToFile(e); let i = await window.WWebJS.getFileHash(t), a = await window.WWebJS.generateHash(32); const n = new AbortController, o = await window.SWA_Store.UploadUtils.encryptAndUpload({ blob: t, type: "sticker", signal: n.signal, mediaKey: a }); return { ...o, clientUrl: o.url, deprecatedMms3Url: o.url, uploadhash: o.encFilehash, size: t.size, type: "sticker", filehash: i } }, window.WWebJS.processMediaData = async (e, { forceVoice: t, forceDocument: i, forceGif: a }) => { const n = window.WWebJS.mediaInfoToFile(e), o = await window.SWA_Store.OpaqueData.createFromData(n, n.type), s = window.SWA_Store.MediaPrep.prepRawMedia(o, { asDocument: i }), r = await s.waitForPrep(), d = window.SWA_Store.MediaObject.getOrCreateMediaObject(r.filehash), c = window.SWA_Store.MediaTypes.msgToMediaType({ type: r.type, isGif: r.isGif }); if (t && "audio" === r.type) { r.type = "ptt"; const e = d.contentInfo.waveform; r.waveform = e ?? await window.WWebJS.generateWaveform(n) } a && "video" === r.type && (r.isGif = !0), i && (r.type = "document"), r.mediaBlob instanceof window.SWA_Store.OpaqueData || (r.mediaBlob = await window.SWA_Store.OpaqueData.createFromData(r.mediaBlob, r.mediaBlob.type)), r.renderableUrl = r.mediaBlob.url(), d.consolidate(r.toJSON()), r.mediaBlob.autorelease(); const l = (await window.SWA_Store.MediaUpload.uploadMedia({ mimetype: r.mimetype, mediaObject: d, mediaType: c })).mediaEntry; if (!l) throw new Error("upload failed: media entry was not created"); return r.set({ clientUrl: l.mmsUrl, deprecatedMms3Url: l.deprecatedMms3Url, directPath: l.directPath, mediaKey: l.mediaKey, mediaKeyTimestamp: l.mediaKeyTimestamp, filehash: d.filehash, encFilehash: l.encFilehash, uploadhash: l.uploadHash, size: d.size, streamingSidecar: l.sidecar, firstFrameSidecar: l.firstFrameSidecar }), r }, window.WWebJS.getMessageModel = e => { var t; const i = e.serialize(); return i.isEphemeral = e.isEphemeral, i.isStatusV3 = e.isStatusV3, i.links = (null == (t = window.SWA_Store.Validators) ? void 0 : t.findLinks(e.mediaObject ? e.caption : e.body)).map((e => ({ link: e.href, isSuspicious: Boolean(e.suspiciousCharacters && e.suspiciousCharacters.size) }))), i.buttons && (i.buttons = i.buttons.serialize()), i.dynamicReplyButtons && (i.dynamicReplyButtons = JSON.parse(JSON.stringify(i.dynamicReplyButtons))), i.replyButtons && (i.replyButtons = JSON.parse(JSON.stringify(i.replyButtons))), "object" == typeof i.id.remote && (i.id = Object.assign({}, i.id, { remote: i.id.remote._serialized })), delete i.pendingAckUpdate, i }, window.WWebJS.getChatModel = async e => { let t = e.serialize(); if (t.isGroup = !1, t.formattedTitle = e.formattedTitle, t.isMuted = 0 != e.muteExpiration, e.groupMetadata) { t.isGroup = !0; const i = window.SWA_Store.WidFactory.createWid(e.id._serialized); await window.SWA_Store.GroupMetadata.update(i), e.groupMetadata.participants._models.filter((e => e.id._serialized.endsWith("@lid"))).forEach((e => { var t; e.id = null == (t = e.contact) ? void 0 : t.phoneNumber })), t.groupMetadata = e.groupMetadata.serialize() } if (t.lastMessage = null, t.msgs && t.msgs.length) { const i = e.lastReceivedKey ? window.SWA_Store.Msg.get(e.lastReceivedKey._serialized) : null; i && (t.lastMessage = window.WWebJS.getMessageModel(i)) } return delete t.msgs, delete t.msgUnsyncedButtonReplyMsgs, delete t.unsyncedButtonReplies, t }, window.WWebJS.getChat = async e => { const t = window.SWA_Store.WidFactory.createWid(e), i = await window.SWA_Store.Chat.find(t); let a = await window.WWebJS.getChatModel(i); return console.log("res>>> getChat", a), a }, window.WWebJS.getChats = async () => { const e = window.SWA_Store.Chat.getModelsArray().map((e => window.WWebJS.getChatModel(e))); return await Promise.all(e) }, window.WWebJS.getContactModel = e => { let t = e.serialize(); t.isBusiness = void 0 !== e.isBusiness && e.isBusiness, e.businessProfile && (t.businessProfile = e.businessProfile.serialize()); const i = window.WWebJS.compareWwebVersions(window.Debug.VERSION, "<", "2.2327.4"); return t.isMe = i ? e.isMe : window.SWA_Store.ContactMethods.getIsMe(e), t.isUser = i ? e.isUser : window.SWA_Store.ContactMethods.getIsUser(e), t.isGroup = i ? e.isGroup : window.SWA_Store.ContactMethods.getIsGroup(e), t.isWAContact = i ? e.isWAContact : window.SWA_Store.ContactMethods.getIsWAContact(e), t.isMyContact = i ? e.isMyContact : window.SWA_Store.ContactMethods.getIsMyContact(e), t.isBlocked = e.isContactBlocked, t.userid = i ? e.userid : window.SWA_Store.ContactMethods.getUserid(e), t.isEnterprise = i ? e.isEnterprise : window.SWA_Store.ContactMethods.getIsEnterprise(e), t.verifiedName = i ? e.verifiedName : window.SWA_Store.ContactMethods.getVerifiedName(e), t.verifiedLevel = i ? e.verifiedLevel : window.SWA_Store.ContactMethods.getVerifiedLevel(e), t.statusMute = i ? e.statusMute : window.SWA_Store.ContactMethods.getStatusMute(e), t.name = i ? e.name : window.SWA_Store.ContactMethods.getName(e), t.shortName = i ? e.shortName : window.SWA_Store.ContactMethods.getShortName(e), t.pushname = i ? e.pushname : window.SWA_Store.ContactMethods.getPushname(e), t }, window.WWebJS.getContact = async e => { const t = window.SWA_Store.WidFactory.createWid(e); let i = await window.SWA_Store.Contact.find(t); i.id._serialized.endsWith("@lid") && (i.id = null == i ? void 0 : i.phoneNumber); const a = await window.SWA_Store.BusinessProfile.fetchBizProfile(t); return a.profileOptions && (i.businessProfile = a), window.WWebJS.getContactModel(i) }, window.WWebJS.getContacts = () => window.SWA_Store.Contact.getModelsArray().map((e => window.WWebJS.getContactModel(e))), window.WWebJS.mediaInfoToFile = ({ data: e, mimetype: t, filename: i }) => { const a = window.atob(e), n = new ArrayBuffer(a.length), o = new Uint8Array(n); for (let r = 0; r < a.length; r++)o[r] = a.charCodeAt(r); const s = new Blob([n], { type: t }); return new File([s], i, { type: t, lastModified: Date.now() }) }, window.WWebJS.arrayBufferToBase64 = e => { let t = ""; const i = new Uint8Array(e), a = i.byteLength; for (let n = 0; n < a; n++)t += String.fromCharCode(i[n]); return window.btoa(t) }, window.WWebJS.arrayBufferToBase64Async = e => new Promise(((t, i) => { const a = new Blob([e], { type: "application/octet-stream" }), n = new FileReader; n.onload = () => { const [, e] = n.result.split(","); t(e) }, n.onerror = e => i(e), n.readAsDataURL(a) })), window.WWebJS.getFileHash = async e => { let t = await e.arrayBuffer(); const i = await crypto.subtle.digest("SHA-256", t); return btoa(String.fromCharCode(...new Uint8Array(i))) }, window.WWebJS.generateHash = async e => { for (var t = "", i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", a = 0; a < e; a++)t += i.charAt(Math.floor(62 * Math.random())); return t }, window.WWebJS.generateWaveform = async e => { try { const t = await e.arrayBuffer(), i = new AudioContext, a = (await i.decodeAudioData(t)).getChannelData(0), n = 64, o = Math.floor(a.length / n), s = []; for (let e = 0; e < n; e++) { const t = o * e; let i = 0; for (let e = 0; e < o; e++)i += Math.abs(a[t + e]); s.push(i / o) } const r = Math.pow(Math.max(...s), -1), d = s.map((e => e * r)); return new Uint8Array(d.map((e => Math.floor(100 * e)))) } catch (t) { return } }, window.WWebJS.sendChatstate = async (e, t) => { switch (t = window.SWA_Store.WidFactory.createWid(t), e) { case "typing": await window.SWA_Store.ChatState.sendChatStateComposing(t); break; case "recording": await window.SWA_Store.ChatState.sendChatStateRecording(t); break; case "stop": await window.SWA_Store.ChatState.sendChatStatePaused(t); break; default: throw "Invalid chatstate" }return !0 }, window.WWebJS.getLabelModel = e => { let t = e.serialize(); return t.hexColor = e.hexColor, t }, window.WWebJS.getLabels = () => window.SWA_Store.Label.getModelsArray().map((e => window.WWebJS.getLabelModel(e))), window.WWebJS.getLabel = e => { const t = window.SWA_Store.Label.get(e); return window.WWebJS.getLabelModel(t) }, window.WWebJS.getChatLabels = async e => ((await window.WWebJS.getChat(e)).labels || []).map((e => window.WWebJS.getLabel(e))), window.WWebJS.cropAndResizeImage = async (e, t = {}) => { if (!e.mimetype.includes("image")) throw new Error("Media is not an image"); t.mimetype && !t.mimetype.includes("image") && delete t.mimetype, t = Object.assign({ size: 640, mimetype: e.mimetype, quality: .75, asDataUrl: !1 }, t); const i = await new Promise(((t, i) => { const a = new Image; a.onload = () => t(a), a.onerror = i, a.src = `data:${e.mimetype};base64,${e.data}` })), a = Math.min(i.width, i.height), n = Math.floor((i.width - a) / 2), o = Math.floor((i.height - a) / 2), s = document.createElement("canvas"); s.width = t.size, s.height = t.size; s.getContext("2d").drawImage(i, n, o, a, a, 0, 0, t.size, t.size); const r = s.toDataURL(t.mimetype, t.quality); return t.asDataUrl ? r : Object.assign(e, { mimetype: t.mimeType, data: r.replace(`data:${t.mimeType};base64,`, "") }) }, window.WWebJS.compareWwebVersions = (e, t, i) => { if (![">", ">=", "<", "<=", "="].includes(t)) throw new class extends Error { constructor(e) { super(e), this.name = "CompareWwebVersionsError" } }("Invalid comparison operator is provided"); if ("string" != typeof e || "string" != typeof i) throw new class extends Error { constructor(e) { super(e), this.name = "CompareWwebVersionsError" } }("A non-string WWeb version type is provided"); for (e = e.replace(/-beta$/, ""), i = i.replace(/-beta$/, ""); e.length !== i.length;)e.length > i.length ? i = i.concat("0") : e = e.concat("0"); return e = Number(e.replace(/\./g, "")), i = Number(i.replace(/\./g, "")), ">" === t ? e > i : ">=" === t ? e >= i : "<" === t ? e < i : "<=" === t ? e <= i : "=" === t && e === i } } class Z { constructor(e) { Object.defineProperty(this, "client", { value: e }) } _clone() { return Object.assign(Object.create(this), this) } _patch(e) { return e } } class ee { constructor(e, t, i, a) { this.mimetype = e, this.data = t, this.filename = i, this.filesize = a } } class te { constructor(e, t, i = {}) { this.latitude = e, this.longitude = t, this.name = i.name, this.address = i.address, this.url = i.url, this.description = this.name && this.address ? `${this.name}\n${this.address}` : this.name || this.address || "" } } class ie extends Z { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.id, this.retailer_id = e.retailer_id, this.name = e.name, this.description = e.description, super._patch(e) } } class ae extends Z { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.id, this.price = e.price ? e.price : "", this.thumbnailUrl = e.thumbnailUrl, this.currency = e.currency, this.name = e.name, this.quantity = e.quantity, this.data = null, super._patch(e) } async getData() { if (null === this.data) { let e = await this.client.pupPage.evaluate((e => window.WWebJS.getProductMetadata(e)), this.id); this.data = e ? new ie(this.client, e) : void 0 } return this.data } } class ne extends Z { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return e.products && (this.products = e.products.map((e => new ae(this.client, e)))), this.subtotal = e.subtotal, this.total = e.total, this.currency = e.currency, this.createdAt = e.createdAt, super._patch(e) } } class oe extends Z { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.id, this.paymentCurrency = e.paymentCurrency, this.paymentAmount1000 = e.paymentAmount1000, this.paymentMessageReceiverJid = e.paymentMessageReceiverJid, this.paymentTransactionTimestamp = e.paymentTransactionTimestamp, this.paymentStatus = e.paymentStatus, this.paymentTxnStatus = e.paymentTxnStatus, this.paymentNote = e.paymentNoteMsg && e.paymentNoteMsg.body ? e.paymentNoteMsg.body : void 0, super._patch(e) } } class se extends Z { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.msgKey, this.orphan = e.orphan, this.orphanReason = e.orphanReason, this.timestamp = e.timestamp, this.reaction = e.reactionText, this.read = e.read, this.msgId = e.parentMsgKey, this.senderId = e.senderUserJid, this.ack = e.ack, super._patch(e) } } class re extends Z { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.id, this.number = e.userid, this.isBusiness = e.isBusiness, this.isEnterprise = e.isEnterprise, this.labels = e.labels, this.name = e.name, this.pushname = e.pushname, this.sectionHeader = e.sectionHeader, this.shortName = e.shortName, this.statusMute = e.statusMute, this.type = e.type, this.verifiedLevel = e.verifiedLevel, this.verifiedName = e.verifiedName, this.isMe = e.isMe, this.isUser = e.isUser, this.isGroup = e.isGroup, this.isWAContact = e.isWAContact, this.isMyContact = e.isMyContact, this.isBlocked = e.isBlocked, super._patch(e) } async getProfilePicUrl() { return await this.client.getProfilePicUrl(this.id._serialized) } async getFormattedNumber() { return await this.client.getFormattedNumber(this.id._serialized) } async getCountryCode() { return await this.client.getCountryCode(this.id._serialized) } async getChat() { return this.isMe ? null : await this.client.getChatById(this.id._serialized) } async getCommonGroups() { return await this.client.getCommonGroups(this.id._serialized) } } class de extends Z { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this._data = e, this.mediaKey = e.mediaKey, this.id = e.id, this.ack = e.ack, this.hasMedia = Boolean(e.mediaKey && e.directPath), this.body = this.hasMedia ? e.caption || "" : e.body || e.pollName || "", this.type = e.type, this.timestamp = e.t, this.from = "object" == typeof e.from && null !== e.from ? e.from._serialized : e.from, this.to = "object" == typeof e.to && null !== e.to ? e.to._serialized : e.to, this.author = "object" == typeof e.author && null !== e.author ? e.author._serialized : e.author, this.deviceType = "string" == typeof e.id.id && e.id.id.length > 21 ? "android" : "string" == typeof e.id.id && "3A" === e.id.id.substring(0, 2) ? "ios" : "web", this.isForwarded = e.isForwarded, this.forwardingScore = e.forwardingScore || 0, this.isStatus = e.isStatusV3 || "status@broadcast" === e.id.remote, this.isStarred = e.star, this.broadcast = e.broadcast, this.fromMe = e.id.fromMe, this.hasQuotedMsg = !!e.quotedMsg, this.hasReaction = !!e.hasReaction, this.duration = e.duration ? e.duration : void 0, this.location = (() => { if (e.type !== T) return; let t; if (e.loc && "string" == typeof e.loc) { let i = e.loc.split("\n"); t = { name: i[0], address: i[1], url: e.clientUrl } } return new te(e.lat, e.lng, t) })(), this.vCards = e.type === O ? e.vcardList.map((e => e.vcard)) : e.type === U ? [e.body] : [], this.inviteV4 = e.type === B ? { inviteCode: e.inviteCode, inviteCodeExp: e.inviteCodeExp, groupId: e.inviteGrp, groupName: e.inviteGrpName, fromId: "_serialized" in e.from ? e.from._serialized : e.from, toId: "_serialized" in e.to ? e.to._serialized : e.to } : void 0, this.mentionedIds = e.mentionedJidList || [], this.groupMentions = e.groupMentions || [], this.orderId = e.orderId ? e.orderId : void 0, this.token = e.token ? e.token : void 0, this.isGif = Boolean(e.isGif), this.isEphemeral = e.isEphemeral, e.title && (this.title = e.title), e.description && (this.description = e.description), e.businessOwnerJid && (this.businessOwnerJid = e.businessOwnerJid), e.productId && (this.productId = e.productId), e.latestEditSenderTimestampMs && (this.latestEditSenderTimestampMs = e.latestEditSenderTimestampMs), e.latestEditMsgKey && (this.latestEditMsgKey = e.latestEditMsgKey), this.links = e.links, e.dynamicReplyButtons && (this.dynamicReplyButtons = e.dynamicReplyButtons), e.selectedButtonId && (this.selectedButtonId = e.selectedButtonId), e.listResponse && e.listResponse.singleSelectReply.selectedRowId && (this.selectedRowId = e.listResponse.singleSelectReply.selectedRowId), this.type === G && (this.pollName = e.pollName, this.pollOptions = e.pollOptions, this.allowMultipleAnswers = Boolean(!e.pollSelectableOptionsCount), this.pollInvalidated = e.pollInvalidated, this.isSentCagPollCreation = e.isSentCagPollCreation, delete this._data.pollName, delete this._data.pollOptions, delete this._data.pollSelectableOptionsCount, delete this._data.pollInvalidated, delete this._data.isSentCagPollCreation), super._patch(e) } _getChatId() { return this.fromMe ? this.to : this.from } async reload() { const e = await this.client.pupPage.evaluate((e => { const t = window.SWA_Store.Msg.get(e); return t ? window.WWebJS.getMessageModel(t) : null }), this.id._serialized); return e ? (this._patch(e), this) : null } get rawData() { return this._data } getChat() { return this.client.getChatById(this._getChatId()) } getContact() { return this.client.getContactById(this.author || this.from) } async getMentions() { return await Promise.all(this.mentionedIds.map((async e => await this.client.getContactById(e)))) } async getGroupMentions() { return await Promise.all(this.groupMentions.map((async e => await this.client.getChatById(e.groupJid._serialized)))) } async getQuotedMessage() { if (!this.hasQuotedMsg) return; const e = await this.client.pupPage.evaluate((e => { const t = window.SWA_Store.Msg.get(e), i = window.SWA_Store.QuotedMsg.getQuotedMsgObj(t); return window.WWebJS.getMessageModel(i) }), this.id._serialized); return new de(this.client, e) } async reply(e, t, i = {}) { return t || (t = this._getChatId()), i = { ...i, quotedMessageId: this.id._serialized }, this.client.sendMessage(t, e, i) } async acceptGroupV4Invite() { return await this.client.acceptGroupV4Invite(this.inviteV4) } async delete(e) { await this.client.pupPage.evaluate((async (e, t) => { let i = window.SWA_Store.Msg.get(e), a = await window.SWA_Store.Chat.find(i.id.remote); const n = window.SWA_Store.MsgActionChecks.canSenderRevokeMsg(i) || window.SWA_Store.MsgActionChecks.canAdminRevokeMsg(i); return t && n ? window.SWA_Store.Cmd.sendRevokeMsgs(a, [i], { clearMedia: !0, type: i.id.fromMe ? "Sender" : "Admin" }) : window.SWA_Store.Cmd.sendDeleteMsgs(a, [i], !0) }), this.id._serialized, e) } async star() { await this.client.pupPage.evaluate((async e => { let t = window.SWA_Store.Msg.get(e); if (window.SWA_Store.MsgActionChecks.canStarMsg(t)) { let e = await window.SWA_Store.Chat.find(t.id.remote); return window.SWA_Store.Cmd.sendStarMsgs(e, [t], !1) } }), this.id._serialized) } async unstar() { await this.client.pupPage.evaluate((async e => { let t = window.SWA_Store.Msg.get(e); if (window.SWA_Store.MsgActionChecks.canStarMsg(t)) { let e = await window.SWA_Store.Chat.find(t.id.remote); return window.SWA_Store.Cmd.sendUnstarMsgs(e, [t], !1) } }), this.id._serialized) } async getInfo() { return await this.client.pupPage.evaluate((async e => { const t = window.SWA_Store.Msg.get(e); return t && t.id.fromMe ? new Promise((e => { setTimeout((async () => { e(await window.SWA_Store.getMsgInfo(t.id)) }), Date.now() - 1e3 * t.t < 1250 && Math.floor(101 * Math.random()) + 1100 || 0) })) : null }), this.id._serialized) } async getOrder() { if (this.type === D) { const e = await this.client.pupPage.evaluate(((e, t, i) => window.WWebJS.getOrderDetail(e, t, i)), this.orderId, this.token, this._getChatId()); if (!e) return; return new ne(this.client, e) } } async getPayment() { if (this.type === R) { const e = await this.client.pupPage.evaluate((async e => { const t = window.SWA_Store.Msg.get(e); return t ? t.serialize() : null }), this.id._serialized); return new oe(this.client, e) } } async getReactions() { if (!this.hasReaction) return; const e = await this.client.pupPage.evaluate((async e => { const t = await window.SWA_Store.Reactions.find(e); return t && t.reactions.length ? t.reactions.serialize() : null }), this.id._serialized); return e ? e.map((e => (e.senders = e.senders.map((e => (e.timestamp = Math.round(e.timestamp / 1e3), new se(this.client, e)))), e))) : void 0 } async edit(e, t = {}) { t.mentions && (!Array.isArray(t.mentions) && (t.mentions = [t.mentions]), t.mentions.some((e => e instanceof re)) && (console.warn("Mentions with an array of Contact are now deprecated. See more at https://github.com/pedroslopez/whatsapp-web.js/pull/2166."), t.mentions = t.mentions.map((e => e.id._serialized)))), t.groupMentions && !Array.isArray(t.groupMentions) && (t.groupMentions = [t.groupMentions]); let i = { linkPreview: !1 !== t.linkPreview || void 0, mentionedJidList: t.mentions || [], groupMentions: t.groupMentions, extraOptions: t.extra }; if (!this.fromMe) return null; const a = await this.client.pupPage.evaluate((async (e, t, i) => { let a = window.SWA_Store.Msg.get(e); if (!a) return null; if (window.SWA_Store.MsgActionChecks.canEditText(a) || window.SWA_Store.MsgActionChecks.canEditCaption(a)) { return (await window.WWebJS.editMessage(a, t, i)).serialize() } return null }), this.id._serialized, e, i); return a ? new de(this.client, a) : null } } class ce extends Z { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.id, this.name = e.formattedTitle, this.isGroup = e.isGroup, this.isReadOnly = e.isReadOnly, this.unreadCount = e.unreadCount, this.timestamp = e.t, this.archived = e.archive, this.pinned = !!e.pin, this.isMuted = e.isMuted, this.muteExpiration = e.muteExpiration, this.lastMessage = e.lastMessage ? new de(super.client, e.lastMessage) : void 0, super._patch(e) } async sendMessage(e, t) { return this.client.sendMessage(this.id._serialized, e, t) } async sendSeen() { return this.client.sendSeen(this.id._serialized) } async archive() { return this.client.archiveChat(this.id._serialized) } async unarchive() { return this.client.unarchiveChat(this.id._serialized) } async pin() { return this.client.pinChat(this.id._serialized) } async unpin() { return this.client.unpinChat(this.id._serialized) } async mute(e) { return this.client.muteChat(this.id._serialized, e) } async unmute() { return this.client.unmuteChat(this.id._serialized) } async markUnread() { return this.client.markChatUnread(this.id._serialized) } async fetchMessages(e) { return (await this.client.pupPage.evaluate((async (e, t) => { const i = e => !e.isNotification && (!t || void 0 === t.fromMe || e.id.fromMe === t.fromMe), a = window.SWA_Store.Chat.get(e); let n = a.msgs.getModelsArray().filter(i); if (t && t.limit > 0) { for (; n.length < t.limit;) { const e = await window.SWA_Store.ConversationMsgs.loadEarlierMsgs(a); if (!e || !e.length) break; n = [...e.filter(i), ...n] } n.length > t.limit && (n.sort(((e, t) => e.t > t.t ? 1 : -1)), n = n.splice(n.length - t.limit)) } return n.map((e => window.WWebJS.getMessageModel(e))) }), this.id._serialized, e)).map((e => new de(this.client, e))) } async sendStateTyping() { return this.client.pupPage.evaluate((e => (window.WWebJS.sendChatstate("typing", e), !0)), this.id._serialized) } async sendStateRecording() { return this.client.pupPage.evaluate((e => (window.WWebJS.sendChatstate("recording", e), !0)), this.id._serialized) } async clearState() { return this.client.pupPage.evaluate((e => (window.WWebJS.sendChatstate("stop", e), !0)), this.id._serialized) } async getContact() { return await this.client.getContactById(this.id._serialized) } async getLabels() { return this.client.getChatLabels(this.id._serialized) } async changeLabels(e) { return this.client.addOrRemoveLabels(e, [this.id._serialized]) } } class le extends ce { } class ue extends ce { _patch(e) { return this.groupMetadata = e.groupMetadata, super._patch(e) } get owner() { return this.groupMetadata.owner } get createdAt() { return new Date(1e3 * this.groupMetadata.creation) } get description() { return this.groupMetadata.desc } get participants() { return this.groupMetadata.participants } async removeParticipants(e) { return await this.client.pupPage.evaluate((async (e, t) => { const i = window.SWA_Store.WidFactory.createWid(e), a = await window.SWA_Store.Chat.find(i), n = t.map((e => a.groupMetadata.participants.get(e))).filter((e => Boolean(e))); return await window.SWA_Store.GroupParticipants.removeParticipants(a, n), { status: 200 } }), this.id._serialized, e) } async promoteParticipants(e) { return await this.client.pupPage.evaluate((async (e, t) => { const i = window.SWA_Store.WidFactory.createWid(e), a = await window.SWA_Store.Chat.find(i), n = t.map((e => a.groupMetadata.participants.get(e))).filter((e => Boolean(e))); return await window.SWA_Store.GroupParticipants.promoteParticipants(a, n), { status: 200 } }), this.id._serialized, e) } async demoteParticipants(e) { return await this.client.pupPage.evaluate((async (e, t) => { const i = window.SWA_Store.WidFactory.createWid(e), a = await window.SWA_Store.Chat.find(i), n = t.map((e => a.groupMetadata.participants.get(e))).filter((e => Boolean(e))); return await window.SWA_Store.GroupParticipants.demoteParticipants(a, n), { status: 200 } }), this.id._serialized, e) } async deletePicture() { return await this.client.pupPage.evaluate((e => window.WWebJS.deletePicture(e)), this.id._serialized) } async setPicture(e) { return await this.client.pupPage.evaluate(((e, t) => window.WWebJS.setPicture(e, t)), this.id._serialized, e) } async getInviteCode() { return (await this.client.pupPage.evaluate((async e => { const t = window.SWA_Store.WidFactory.createWid(e); return window.SWA_Store.GroupInvite.queryGroupInviteCode(t) }), this.id._serialized)).code } async revokeInvite() { return (await this.client.pupPage.evaluate((e => { const t = window.SWA_Store.WidFactory.createWid(e); return window.SWA_Store.GroupInvite.resetGroupInviteCode(t) }), this.id._serialized)).code } async getGroupMembershipRequests() { return await this.client.getGroupMembershipRequests(this.id._serialized) } async approveGroupMembershipRequests(e = {}) { return await this.client.approveGroupMembershipRequests(this.id._serialized, e) } async rejectGroupMembershipRequests(e = {}) { return await this.client.rejectGroupMembershipRequests(this.id._serialized, e) } } const we = class { static create(e, t) { return t.isGroup ? new ue(e, t) : new le(e, t) } }.create; class pe extends re { } class he extends re { _patch(e) { return this.businessProfile = e.businessProfile, super._patch(e) } } const me = class { static create(e, t) { return t.isBusiness ? new he(e, t) : new pe(e, t) } }.create; class Se extends Z { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.pushname = e.pushname, this.wid = e.wid, this.me = e.wid, this.phone = e.phone, this.platform = e.platform, super._patch(e) } async getBatteryStatus() { return await this.client.pupPage.evaluate((() => { const { battery: e, plugged: t } = window.SWA_Store.Conn; return { battery: e, plugged: t } })) } } class ge extends Z { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.id, this.body = e.body || "", this.type = e.subtype, this.timestamp = e.t, this.chatId = "object" == typeof e.id.remote ? e.id.remote._serialized : e.id.remote, this.author = "object" == typeof e.author ? e.author._serialized : e.author, this.recipientIds = [], e.recipients && (this.recipientIds = e.recipients), super._patch(e) } getChat() { return this.client.getChatById(this.chatId) } getContact() { return this.client.getContactById(this.author) } async getRecipients() { return await Promise.all(this.recipientIds.map((async e => await this.client.getContactById(e)))) } async reply(e, t = {}) { return this.client.sendMessage(this.chatId, e, t) } } class ye extends Z { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { this.id = e.id, this.name = e.name, this.hexColor = e.hexColor } async getChats() { return this.client.getChatsByLabelId(this.id) } } class We { constructor(e, t, i, a) { if (this.body = e, this.title = i, this.footer = a, e instanceof ee ? (this.type = "media", this.title = "") : this.type = "chat", this.buttons = this._format(t), !this.buttons.length) throw "[BT01] No buttons" } _format(e) { return (e = e.slice(0, 3)).map((e => ({ buttonId: e.id ? String(e.id) : w(6), buttonText: { displayText: e.body }, type: 1 }))) } } class _e { constructor(e, t, i, a, n) { this.description = e, this.buttonText = t, this.title = a, this.footer = n, this.sections = this._format(i) } _format(e) { if (!e.length) throw "[LT02] List without sections"; if (e.length > 1 && e.filter((e => void 0 === e.title)).length > 1) throw "[LT05] You can't have more than one empty title."; return e.map((e => { if (!e.rows.length) throw "[LT03] Section without rows"; return { title: e.title ? e.title : void 0, rows: e.rows.map((e => { if (!e.title) throw "[LT04] Row without title"; return { rowId: e.id ? e.id : w(6), title: e.title, description: e.description ? e.description : "" } })) } })) } } class Ae { constructor(e, t, i = {}) { this.pollName = e.trim(), this.pollOptions = t.map(((e, t) => ({ name: e.trim(), localId: t }))), this.options = { allowMultipleAnswers: !0 === i.allowMultipleAnswers, messageSecret: i.messageSecret } } } (new class extends l { constructor(e = {}) { super(), this.options = function (e, t) { if (!t) return e; for (const n in e) i = t, a = n, Object.prototype.hasOwnProperty.call(i, a) && void 0 !== t[n] ? t[n] === Object(t[n]) && (t[n] = Util.mergeDefault(e[n], t[n])) : t[n] = e[n]; var i, a; return t }(m, e), this.pupPage = u.Page, this.currentIndexHtml = null, this.lastLoggedOut = !1 } async inject(e = !1) { await this.pupPage.waitForFunction((() => { var e; return null != (null == (e = window.Debug) ? void 0 : e.VERSION) }), { timeout: this.options.authTimeoutMs }), await this.pupPage.evaluate($); const t = await this.pupPage.evaluate((async () => { let e = window.SWA_AuthStore.AppState.state; return "OPENING" !== e && "UNLAUNCHED" !== e && "PAIRING" !== e || await new Promise((e => { window.SWA_AuthStore.AppState.on("change:state", (function t(i, a) { "OPENING" !== a && "UNLAUNCHED" !== a && "PAIRING" !== a && (window.SWA_AuthStore.AppState.off("change:state", t), e()) })) })), e = window.SWA_AuthStore.AppState.state, "UNPAIRED" == e || "UNPAIRED_IDLE" == e })); console.log("is authentication needed", t), t && console.log("authentication needed"), e || (await this.pupPage.exposeFunction("onAuthAppStateChangedEvent", (async e => { })), await this.pupPage.exposeFunction("onAppStateHasSyncedEvent", (async () => { await this.pupPage.evaluate((async () => void 0 !== window.SWA_Store && void 0 !== window.WWebJS)) || (await new Promise((e => setTimeout(e, 1e3))), await this.pupPage.evaluate(X), await this.pupPage.waitForFunction((() => null != window.SWA_Store)), this.info = new Se(this, await this.pupPage.evaluate((() => ({ ...window.SWA_Store.Conn.serialize(), wid: window.SWA_Store.User.getMaybeMePnUser })))), this.interface = new h(this), await this.pupPage.evaluate(Y), await this.attachEventListeners(e), e = !0), this.emit(S) })), await this.pupPage.exposeFunction("onOfflineProgressUpdateEvent", (async e => { this.emit(N, e, "WhatsApp") }))), await this.pupPage.evaluate((() => { window.SWA_AuthStore.AppState.on("change:state", ((e, t) => { window.onAuthAppStateChangedEvent(t) })), window.SWA_AuthStore.AppState.on("change:hasSynced", (() => { window.onAppStateHasSyncedEvent() })), window.SWA_AuthStore.Cmd.on("offline_progress_update", (() => { window.onOfflineProgressUpdateEvent(window.SWA_AuthStore.OfflineMessageHandler.getOfflineDeliveryProgress()) })) })) } async initialize() { await this.inject() } async requestPairingCode(e, t = !0) { return await this.pupPage.evaluate((async (e, t) => (window.SWA_AuthStore.PairingCodeLinkUtils.setPairingType("ALT_DEVICE_LINKING"), await window.SWA_AuthStore.PairingCodeLinkUtils.initializeAltDeviceLinking(), window.SWA_AuthStore.PairingCodeLinkUtils.startAltLinkingFlow(e, t))), e, t) } async attachEventListeners(e = !1) { if (!e) { let e; await this.pupPage.exposeFunction("onAddMessageEvent", (e => { if ("gp2" === e.type) { const t = new ge(this, e); return void (["add", "invite", "linked_group_join"].includes(e.subtype) ? this.emit(E, t) : "remove" === e.subtype || "leave" === e.subtype ? this.emit(F, t) : "promote" === e.subtype || "demote" === e.subtype ? this.emit(L, t) : "created_membership_requests" === e.subtype ? this.emit(J, t) : this.emit(q, t)) } const t = new de(this, e); this.emit(A, t), e.id.fromMe || this.emit(W, t) })), await this.pupPage.exposeFunction("onChangeMessageTypeEvent", (t => { if ("revoked" === t.type) { const i = new de(this, t); let a; e && t.id.id === e.id.id && (a = new de(this, e)), this.emit(f, i, a) } })), await this.pupPage.exposeFunction("onChangeMessageEvent", (t => { "revoked" !== t.type && (e = t); const i = "gp2" === t.type && "modify" === t.subtype, a = "notification_template" === t.type && "change_number" === t.subtype; if (i || a) { const e = new de(this, t), n = i ? t.recipients[0] : t.to, o = i ? t.author : t.templateParams.find((e => e !== n)); this.emit(I, e, o, n, a) } })), await this.pupPage.exposeFunction("onRemoveMessageEvent", (e => { if (!e.isNewMsg) return; const t = new de(this, e); this.emit(b, t) })), await this.pupPage.exposeFunction("onMessageAckEvent", ((e, t) => { const i = new de(this, e); this.emit(v, i, t) })), await this.pupPage.exposeFunction("onChatUnreadCountEvent", (async e => { const t = await this.getChatById(e.id); this.emit(M, t) })), await this.pupPage.exposeFunction("onMessageMediaUploadedEvent", (e => { const t = new de(this, e); this.emit(k, t) })), await this.pupPage.exposeFunction("onAppStateChangedEvent", (async e => { this.emit(z, e); const t = [j, K, H, Q]; this.options.takeoverOnConflict && (t.push(V), e === V && setTimeout((() => { this.pupPage.evaluate((() => window.SWA_Store.AppState.takeover())) }), this.options.takeoverTimeoutMs)), t.includes(e) || (this.emit(x, e), this.destroy()) })), await this.pupPage.exposeFunction("onReaction", (e => { for (const t of e) this.emit(P, new se(this, t)) })), await this.pupPage.exposeFunction("onRemoveChatEvent", (async e => { const t = await this.getChatById(e.id); this.emit(g, t) })), await this.pupPage.exposeFunction("onArchiveChatEvent", (async (e, t, i) => { const a = await this.getChatById(e.id); this.emit(y, a, t, i) })), await this.pupPage.exposeFunction("onEditMessageEvent", ((e, t, i) => { "revoked" !== e.type && this.emit(C, new de(this, e), t, i) })), await this.pupPage.exposeFunction("onAddMessageCiphertextEvent", (e => { this.emit(_, new de(this, e)) })) } await this.pupPage.evaluate((() => { window.SWA_Store.Msg.on("change:ack", ((e, t) => { window.onMessageAckEvent(window.WWebJS.getMessageModel(e), t) })) })) } async destroy() { } async logout() { await this.pupPage.evaluate((() => window.SWA_Store.AppState.logout())) } async getWWebVersion() { return await this.pupPage.evaluate((() => window.Debug.VERSION)) } async sendSeen(e) { return await this.pupPage.evaluate((async e => window.WWebJS.sendSeen(e)), e) } async sendMessage(e, t, i = {}) { i.mentions && (!Array.isArray(i.mentions) && (i.mentions = [i.mentions]), i.mentions.some((e => e instanceof re)) && (console.warn("Mentions with an array of Contact are now deprecated. See more at https://github.com/pedroslopez/whatsapp-web.js/pull/2166."), i.mentions = i.mentions.map((e => e.id._serialized)))), i.groupMentions && !Array.isArray(i.groupMentions) && (i.groupMentions = [i.groupMentions]); let a = { linkPreview: !1 !== i.linkPreview || void 0, sendAudioAsVoice: i.sendAudioAsVoice, sendVideoAsGif: i.sendVideoAsGif, sendMediaAsSticker: i.sendMediaAsSticker, sendMediaAsDocument: i.sendMediaAsDocument, caption: i.caption, quotedMessageId: i.quotedMessageId, parseVCards: !1 !== i.parseVCards, mentionedJidList: i.mentions || [], groupMentions: i.groupMentions, extraOptions: i.extra }; const n = void 0 === i.sendSeen || i.sendSeen; t instanceof ee ? (a.attachment = t, a.isViewOnce = i.isViewOnce, t = "") : i.media instanceof ee ? (a.attachment = i.media, a.caption = t, a.isViewOnce = i.isViewOnce, t = "") : t instanceof te ? (a.location = t, t = "") : t instanceof Ae ? (a.poll = t, t = "") : t instanceof re ? (a.contactCard = t.id._serialized, t = "") : Array.isArray(t) && t.length > 0 && t[0] instanceof re ? (a.contactCardList = t.map((e => e.id._serialized)), t = "") : t instanceof We ? ("chat" !== t.type && (a.attachment = t.body), a.buttons = t, t = "") : t instanceof _e && (a.list = t, t = ""), a.sendMediaAsSticker && a.attachment && (a.attachment = await formatToWebpSticker(a.attachment, { name: i.stickerName, author: i.stickerAuthor, categories: i.stickerCategories }, this.pupPage)); const o = await this.pupPage.evaluate((async (e, t, i, a) => { const n = window.SWA_Store.WidFactory.createWid(e), o = await window.SWA_Store.Chat.find(n); a && await window.WWebJS.sendSeen(e); const s = await window.WWebJS.sendMessage(o, t, i, a); return window.WWebJS.getMessageModel(s) }), e, t, a, n); return new de(this, o) } async searchMessages(e, t = {}) { return (await this.pupPage.evaluate((async (e, t, i, a) => { const { messages: n } = await window.SWA_Store.Msg.search(e, t, i, a); return n.map((e => window.WWebJS.getMessageModel(e))) }), e, t.page, t.limit, t.chatId)).map((e => new de(this, e))) } async getChats() { return (await this.pupPage.evaluate((async () => await window.WWebJS.getChats()))).map((e => we(this, e))) } async getChatById(e) { let t = await this.pupPage.evaluate((async e => await window.WWebJS.getChat(e)), e); return we(this, t) } async getContacts() { return (await this.pupPage.evaluate((() => window.WWebJS.getContacts()))).map((e => me(this, e))) } async getContactById(e) { let t = await this.pupPage.evaluate((e => window.WWebJS.getContact(e)), e); return me(this, t) } async getMessageById(e) { const t = await this.pupPage.evaluate((async e => { let t = window.SWA_Store.Msg.get(e); if (t) return window.WWebJS.getMessageModel(t); if (3 !== e.split("_").length) throw new Error("Invalid serialized message id specified"); let i = await window.SWA_Store.Msg.getMessagesById([e]); return i && i.messages.length && (t = i.messages[0]), t ? window.WWebJS.getMessageModel(t) : void 0 }), e); return t ? new de(this, t) : null } async getInviteInfo(e) { return await this.pupPage.evaluate((e => window.SWA_Store.GroupInvite.queryGroupInvite(e)), e) } async acceptInvite(e) { return (await this.pupPage.evaluate((async e => await window.SWA_Store.GroupInvite.joinGroupViaInvite(e)), e)).gid._serialized } async getState() { return await this.pupPage.evaluate((() => window.SWA_Store ? window.SWA_Store.AppState.state : null)) } async archiveChat(e) { return await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Chat.get(e); return await window.SWA_Store.Cmd.archiveChat(t, !0), !0 }), e) } async unarchiveChat(e) { return await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Chat.get(e); return await window.SWA_Store.Cmd.archiveChat(t, !1), !1 }), e) } async pinChat(e) { return this.pupPage.evaluate((async e => { let t = window.SWA_Store.Chat.get(e); if (t.pin) return !0; const i = window.SWA_Store.Chat.getModelsArray(); if (i.length > 3) { if (i[2].pin) return !1 } return await window.SWA_Store.Cmd.pinChat(t, !0), !0 }), e) } async unpinChat(e) { return this.pupPage.evaluate((async e => { let t = window.SWA_Store.Chat.get(e); return !!t.pin && (await window.SWA_Store.Cmd.pinChat(t, !1), !1) }), e) } async muteChat(e, t) { t = t ? t.getTime() / 1e3 : -1, await this.pupPage.evaluate((async (e, t) => { let i = await window.SWA_Store.Chat.get(e); await i.mute.mute({ expiration: t, sendDevice: !0 }) }), e, t || -1) } async unmuteChat(e) { await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Chat.get(e); await window.SWA_Store.Cmd.muteChat(t, !1) }), e) } async markChatUnread(e) { await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Chat.get(e); await window.SWA_Store.Cmd.markChatUnread(t, !0) }), e) } async getCommonGroups(e) { const t = await this.pupPage.evaluate((async e => { let t = window.SWA_Store.Contact.get(e); if (!t) { const i = window.SWA_Store.WidFactory.createUserWid(e); t = new (0, window.SWA_Store.Contact.getModelsArray().find((e => !e.isGroup)).constructor)({ id: i }) } if (t.commonGroups) return t.commonGroups.serialize(); return await window.SWA_Store.findCommonGroups(t) ? t.commonGroups.serialize() : [] }), e), i = []; for (const a of t) i.push(a.id); return i } async resetState() { await this.pupPage.evaluate((() => { window.SWA_Store.AppState.phoneWatchdog.shiftTimer.forceRunNow() })) } async isRegisteredUser(e) { return Boolean(await this.getNumberId(e)) } async getNumberId(e, t) { var i; e = String(e).replace("@c.us", ""); const a = (() => { var e; try { return !!(null == (e = window.require("WAComms")) ? void 0 : e.getComms()) } catch (t) { return !0 } })(); try { a || await (null == (i = require("WAWebStartBackend")) ? void 0 : i.startBackend()) } catch (n) { } return await this.pupPage.evaluate((async e => { let i = p(e, t); e = i.number, (t = i.countryCode) || (t = window.SWA_Store.PhoneFindCC.findCC(e), e = e.substring(t.length)); let a = await window.SWA_Store.PhoneNumberFormatUtils.isPhoneNumberValid(Number(t), e); if (a || (i = p(e, t), e = i.number, t = i.countryCode), 975 != Number(t) && (c("Checking for valid number", t, e), a = await window.SWA_Store.PhoneNumberFormatUtils.isPhoneNumberValid(Number(t), e), !a)) return null; const n = await window.SWA_Store.QueryExistJob.queryPhoneExists(`+${i.fullNumber}`); return n && void 0 !== n.wid ? n.wid : null }), e) } async getFormattedNumber(e) { return e.endsWith("@s.whatsapp.net") || (e = e.replace("c.us", "s.whatsapp.net")), e.includes("@s.whatsapp.net") || (e = `${e}@s.whatsapp.net`), await this.pupPage.evaluate((async e => window.SWA_Store.NumberInfo.formattedPhoneNumber(e)), e) } async getCountryCode(e) { return e = e.replace(" ", "").replace("+", "").replace("@c.us", ""), await this.pupPage.evaluate((async e => window.SWA_Store.NumberInfo.findCC ? window.SWA_Store.NumberInfo.findCC(e) : window.SWA_Store.PhoneFindCC.findCC(e)), e) } async getLabels() { return (await this.pupPage.evaluate((async () => window.WWebJS.getLabels()))).map((e => new ye(this, e))) } async getLabelById(e) { const t = await this.pupPage.evaluate((async e => window.WWebJS.getLabel(e)), e); return new ye(this, t) } async getChatLabels(e) { return (await this.pupPage.evaluate((async e => window.WWebJS.getChatLabels(e)), e)).map((e => new ye(this, e))) } async getChatsByLabelId(e) { const t = await this.pupPage.evaluate((async e => window.SWA_Store.Label.get(e).labelItemCollection.getModelsArray().reduce(((e, t) => ("Chat" === t.parentType && e.push(t.parentId), e)), [])), e); return Promise.all(t.map((e => this.getChatById(e)))) } async getBlockedContacts() { return (await this.pupPage.evaluate((() => { let e = window.SWA_Store.Blocklist.getModelsArray().map((e => e.id._serialized)); return Promise.all(e.map((e => window.WWebJS.getContact(e)))) }))).map((e => me(this.client, e))) } async setProfilePicture(e) { return await this.pupPage.evaluate(((e, t) => window.WWebJS.setPicture(e, t)), this.info.wid._serialized, e) } async deleteProfilePicture() { return await this.pupPage.evaluate((e => window.WWebJS.deletePicture(e)), this.info.wid._serialized) } async addOrRemoveLabels(e, t) { return this.pupPage.evaluate((async (e, t) => { if (-1 === ["smba", "smbi"].indexOf(window.SWA_Store.Conn.platform)) throw "[LT01] Only Whatsapp business"; const i = window.WWebJS.getLabels().filter((t => void 0 !== e.find((e => e == t.id)))), a = window.SWA_Store.Chat.filter((e => t.includes(e.id._serialized))); let n = i.map((e => ({ id: e.id, type: "add" }))); return a.forEach((e => { (e.labels || []).forEach((e => { n.find((t => t.id == e)) || n.push({ id: e, type: "remove" }) })) })), await window.SWA_Store.Label.addOrRemoveLabels(n, a) }), e, t) } async getGroupMembershipRequests(e) { return await this.pupPage.evaluate((async e => { const t = window.SWA_Store.WidFactory.createWid(e); return await window.SWA_Store.MembershipRequestUtils.getMembershipApprovalRequests(t) }), e) } }).on("message_ack", (e => { c("Got acknolegement", e.ack, e); const t = new CustomEvent("msg_ack", { detail: { id: e.id.id, msg: e.body, ack: e.ack } }); document.body.dispatchEvent(t) })); const fe = { number: "", CCode: "", phoneNumber: "", userName: "" }; const be = class e { static async storage(t) { if (t.set) return void (await Ce({ requestKey: "fetchData-" + __privateWrapper(e, i)._++, data: { action: "storage", set: t.set } })); return await Ce({ requestKey: "fetchData-" + __privateWrapper(e, i)._++, data: { action: "storage", get: t.get } }) } }; i = new WeakMap, __privateAdd(be, i, 1), __publicField(be, "get", (async (e, t) => { const a = await Ce({ requestKey: "fetchData-" + __privateWrapper(be, i)._++, data: { action: "fetchData", data: { url: e, method: "GET", token: null == t ? void 0 : t.token, retryLimit: null == t ? void 0 : t.retryLimit } } }), n = "FetchDataTimeout" == (null == a ? void 0 : a.name), o = "AxiosError" == (null == a ? void 0 : a.name); if (n || o) throw a; return a })), __publicField(be, "post", (async (e, t, a) => { console.log("post", e, t, a); const n = fe, o = (null == a ? void 0 : a.addNumber) && n ? { phoneNumber: n.phoneNumber, CCode: n.CCode, ...t } : t, s = await Ce({ requestKey: "fetchData-" + __privateWrapper(be, i)._++, data: { action: "fetchData", data: { url: e, method: "POST", body: o, token: null == a ? void 0 : a.token, retryLimit: null == a ? void 0 : a.retryLimit } } }), r = "FetchDataTimeout" == (null == s ? void 0 : s.name), d = "AxiosError" == (null == s ? void 0 : s.name); if (r || d) throw s; return s })), __publicField(be, "upload_contact_list", (async e => { console.log("upload_contact_list", e); const t = await Ce({ requestKey: "fetchData-" + __privateWrapper(be, i)._++, data: { action: "upload_contact_list", data: { body: e } } }), a = "FetchDataTimeout" == (null == t ? void 0 : t.name), n = "AxiosError" == (null == t ? void 0 : t.name); if (a || n) throw t; return t })), __publicField(be, "put", (async (e, t, a) => { const n = await Ce({ requestKey: "fetchData-" + __privateWrapper(be, i)._++, data: { action: "fetchData", data: { url: e, method: "PUT", body: t, token: null == a ? void 0 : a.token, retryLimit: null == a ? void 0 : a.retryLimit } } }), o = "FetchDataTimeout" == (null == n ? void 0 : n.name), s = "AxiosError" == (null == n ? void 0 : n.name); if (o || s) throw n; return n })), __publicField(be, "delete", (async (e, t, a) => { const n = await Ce({ requestKey: "fetchData-" + __privateWrapper(be, i)._++, data: { action: "fetchData", data: { url: e, method: "DELETE", body: t, token: null == a ? void 0 : a.token, retryLimit: null == a ? void 0 : a.retryLimit } } }), o = "FetchDataTimeout" == (null == n ? void 0 : n.name), s = "AxiosError" == (null == n ? void 0 : n.name); if (o || s) throw n; return n })), __publicField(be, "logout", (async () => await Ce({ requestKey: "fetchData-" + __privateWrapper(be, i)._++, data: { action: "logout" } }))), __publicField(be, "screenLock", (async e => await Ce({ requestKey: "fetchData-" + __privateWrapper(be, i)._++, data: { action: "screenLock", data: { freeScreen: !!(null == e ? void 0 : e.freeScreen) } } }))); let ve = be; function Ce(e) { return new Promise(((t, i) => { const a = setTimeout((() => { document.body.removeEventListener("connect_sheet_wa_receive", n), i({ name: "FetchDataTimeout", message: "Request timed out", requests: e }) }), 3e4), n = i => { const o = i.detail; o.requestKey === e.requestKey && (t(o.response), document.body.removeEventListener("connect_sheet_wa_receive", n), clearTimeout(a)) }; document.body.addEventListener("connect_sheet_wa_receive", n); const o = new CustomEvent("connect_sheet_wa_sent", { detail: { data: JSON.stringify(e.data), requestKey: e.requestKey } }); document.body.dispatchEvent(o) })) } class Me { } function Pe(e) { return new Promise((t => { chrome.runtime.sendMessage(chrome.runtime.id, { channelName: "request_from_injected_script", data: e }, (e => { t(e) })) })) } function ke(e) { let t = 0; return e.map((e => { "Sent" == e.status && t++ })), t } async function Ie(e, t, i) { var n; c("Saving message limit and total messages sent in db", t, i); try { const o = (null == i ? void 0 : i.completed) || (null == i ? void 0 : i.canceled), r = null == (n = await s(["userData"])) ? void 0 : n.userData; c("Response of updating message limit and total messages sent in db", await ve.post(`${a}/update-msg-report`, { phoneNumber: null == r ? void 0 : r.phoneNumber, CCode: null == r ? void 0 : r.CCode, reportId: e, statusData: t, campaignStatus: i, msgCount: ke(t), campaignEndedAt: o ? new Date : void 0, isCanceled: null == i ? void 0 : i.canceled }, { token: !0, retryLimit: 3 })), c("report data saved to db successfully") } catch (o) { c("error in saveStatusInDb", o); const { message: e, stack: t, ...i } = o; Me.post(`${a}/error-report`, { errorMessage: e, errorStack: t, errorLocation: "Updationg_status: pre_existing_report_data", otherDetails: i, extensionVersion: "5.76" }, { token: !0 }).catch((() => { })) } } __publicField(Me, "get", (async (e, t) => { const i = Pe({ action: "fetchData", data: { url: e, method: "GET", token: null == t ? void 0 : t.token, retryLimit: null == t ? void 0 : t.retryLimit } }); if ("AxiosError" == (null == i ? void 0 : i.name) && (null == i ? void 0 : i.stack)) throw i; return i })), __publicField(Me, "post", (async (e, t, i) => { const a = Pe({ action: "fetchData", data: { url: e, method: "POST", body: t, token: null == i ? void 0 : i.token, retryLimit: null == i ? void 0 : i.retryLimit } }); if ("AxiosError" == (null == a ? void 0 : a.name) && (null == a ? void 0 : a.stack)) throw a; return a })), __publicField(Me, "put", (async (e, t, i) => { const a = Pe({ action: "fetchData", data: { url: e, method: "PUT", body: t, token: null == i ? void 0 : i.token, retryLimit: null == i ? void 0 : i.retryLimit } }); if ("AxiosError" == (null == a ? void 0 : a.name) && (null == a ? void 0 : a.stack)) throw a; return a })), __publicField(Me, "delete", (async (e, t, i) => { const a = Pe({ action: "fetchData", data: { url: e, method: "DELETE", body: t, token: null == i ? void 0 : i.token, retryLimit: null == i ? void 0 : i.retryLimit } }); if ("AxiosError" == (null == a ? void 0 : a.name) && (null == a ? void 0 : a.stack)) throw a; return a })), document.addEventListener("DOMContentLoaded", (() => { function e(e) { e && r({ type: "save_token", payload: { token: e } }) } c("extension connected"), document.body.addEventListener("sheetsToWhatsApp", (t => { e(t.detail.token) })), document.body.addEventListener("isSheetwaInstalled", (() => { console.log("yes sheetwa extension is installed"), document.body.dispatchEvent(new Event("yesSheetwaIsInstalled")) })); try { const t = document.cookie.match(/(?:^|; )user=([^;]*)/); if (c("cookie of user from sheetwa", t), t) { e(JSON.parse(decodeURIComponent(t[1])).token) } } catch (t) { return c("Failed to get token", null == t ? void 0 : t.message), null } document.body.addEventListener("openSheetWA", (() => { console.log("opening extension"), r({ type: "open_extension_from_worker", payload: null }) })) })), async function () { var e, t; const i = null == (e = await s(["report_status"])) ? void 0 : e.report_status, a = null == (t = await s(["is_report_data_saved"])) ? void 0 : t.is_report_data_saved; if (i && Object.keys(i).length && !a) { for (const e in i) if (Object.prototype.hasOwnProperty.call(i, e)) { const t = i[e]; t && t.length && await Ie(e, t) } await ve.storage({ set: { is_report_data_saved: !0 } }) } }().catch((e => { console.error(e) })) }();
