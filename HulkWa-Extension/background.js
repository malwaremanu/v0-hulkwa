var __defProp = Object.defineProperty, __typeError = e => { throw TypeError(e) }, __defNormalProp = (e, t, i) => t in e ? __defProp(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, __publicField = (e, t, i) => __defNormalProp(e, "symbol" != typeof t ? t + "" : t, i), __accessCheck = (e, t, i) => t.has(e) || __typeError("Cannot " + i), __privateGet = (e, t, i) => (__accessCheck(e, t, "read from private field"), i ? i.call(e) : t.get(e)), __privateAdd = (e, t, i) => t.has(e) ? __typeError("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, i), __privateSet = (e, t, i, n) => (__accessCheck(e, t, "write to private field"), n ? n.call(e, i) : t.set(e, i), i), __privateWrapper = (e, t, i, n) => ({ set _(n) { __privateSet(e, t, n, i) }, get _() { return __privateGet(e, t, n) } }); !function () { "use strict"; var e, t, i; const n = "https://web.whatsapp.com"; function a(e) { return t => t.type === e } const o = "https://backend.sheetwa.com"; class r { constructor() { __privateAdd(this, e, {}), __privateAdd(this, t, {}) } emit(i, ...n) { var a; for (__privateGet(this, e)[i] && __privateGet(this, e)[i].forEach((e => { e(...n) })); null == (a = __privateGet(this, t)[i]) ? void 0 : a.length;) { const e = __privateGet(this, t)[i].shift(); e && e(...n) } } on(t, i) { __privateGet(this, e)[t] ? __privateGet(this, e)[t].push(i) : __privateGet(this, e)[t] = [i] } once(e, i) { __privateGet(this, t)[e] ? __privateGet(this, t)[e].push(i) : __privateGet(this, t)[e] = [i] } } e = new WeakMap, t = new WeakMap; const s = { Page: { evaluate: async (e, ...t) => await e(...t), waitForFunction: async (e, { timeout: t } = { timeout: 0 }) => new Promise(((i, n) => { const a = setInterval((() => { e() && (clearInterval(a), i()) }), 500); t && setTimeout((() => { clearInterval(a), e() ? i() : n() }), t) })), waitForSelector: async (e, { timeout: t }) => new Promise(((i, n) => { const a = new MutationObserver(((t, n) => { document.querySelector(e) && (a.disconnect(), i()) })); a.observe(document, { childList: !0, attributes: !0, subtree: !0 }); document.querySelector(e) && (a.disconnect(), i()), t && setTimeout((() => { a.disconnect(), n("timeout") }), t) })), exposeFunction: async (e, t) => { window[e] = t } } }; function d(e) { for (var t = "", i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = 0; n < e; n++)t += i.charAt(Math.floor(62 * Math.random())); return t } function c(e, t) { return e = Number(String(e).replace(/\D/g, "")), t = Number(String(t).replace(/\D/g, "")), { number: e = e ? String(e) : "", countryCode: t = t ? String(t) : "", fullNumber: `${t}${e}` } } class u { constructor(e) { this.pupPage = e.pupPage } async openChatWindow(e) { await this.pupPage.evaluate((async e => { let t = window.SWA_Store.WidFactory.createWid(e), i = await window.SWA_Store.Chat.find(t); await window.SWA_Store.Cmd.openChatAt(i) }), e) } async openChatDrawer(e) { await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Chat.get(e); await window.SWA_Store.Cmd.openDrawerMid(t) }), e) } async openChatSearch(e) { await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Chat.get(e); await window.SWA_Store.Cmd.chatSearch(t) }), e) } async openChatWindowAt(e) { await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Msg.get(e), i = await window.SWA_Store.Chat.find(t.id.remote), n = await window.SWA_Store.SearchContext(i, t); await window.SWA_Store.Cmd.openChatAt(i, n) }), e) } async openMessageDrawer(e) { await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Msg.get(e); await window.SWA_Store.Cmd.msgInfoDrawer(t) }), e) } async getFeatures() { return await this.pupPage.evaluate((() => { if (!window.SWA_Store.Features) throw new Error("This version of Whatsapp Web does not support features"); return window.SWA_Store.Features.F })) } async checkFeatureStatus(e) { return await this.pupPage.evaluate((e => { if (!window.SWA_Store.Features) throw new Error("This version of Whatsapp Web does not support features"); return window.SWA_Store.Features.supportsFeature(e) }), e) } async enableFeatures(e) { await this.pupPage.evaluate((e => { if (!window.SWA_Store.Features) throw new Error("This version of Whatsapp Web does not support features"); for (const t in e) window.SWA_Store.Features.setFeature(e[t], !0) }), e) } async disableFeatures(e) { await this.pupPage.evaluate((e => { if (!window.SWA_Store.Features) throw new Error("This version of Whatsapp Web does not support features"); for (const t in e) window.SWA_Store.Features.setFeature(e[t], !1) }), e) } } const l = { puppeteer: { headless: !0, defaultViewport: null }, webVersion: "2.2346.52", webVersionCache: { type: "local" }, authTimeoutMs: 0, qrMaxRetries: 0, takeoverOnConflict: !1, takeoverTimeoutMs: 0, userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67 Safari/537.36", ffmpegPath: "ffmpeg", bypassCSP: !1, proxyAuthentication: void 0 }, p = "ready", h = "chat_removed", w = "chat_archived", m = "message", f = "message_ciphertext", g = "message_create", S = "message_revoke_everyone", y = "message_revoke_me", b = "message_ack", _ = "message_edit", W = "unread_count", A = "message_reaction", v = "media_uploaded", C = "contact_changed", M = "group_join", P = "group_leave", E = "group_admin_changed", R = "group_membership_request", O = "group_update", k = "loading_screen", T = "disconnected", L = "change_state", x = "location", I = "vcard", F = "multi_vcard", N = "order", U = "groups_v4_invite", B = "payment", q = "poll_creation", D = "CONFLICT", J = "CONNECTED", j = "OPENING", z = "PAIRING", G = "TIMEOUT"; function V() { window.SWA_AuthStore = {}, window.SWA_AuthStore.AppState = window.require("WAWebSocketModel").Socket, window.SWA_AuthStore.Cmd = window.require("WAWebCmd").Cmd, window.SWA_AuthStore.Conn = window.require("WAWebConnModel").Conn, window.SWA_AuthStore.OfflineMessageHandler = window.require("WAWebOfflineHandler").OfflineMessageHandler, window.SWA_AuthStore.PairingCodeLinkUtils = window.require("WAWebAltDeviceLinkingApi"), window.SWA_AuthStore.Base64Tools = window.require("WABase64"), window.SWA_AuthStore.RegistrationUtils = { ...window.require("WAWebCompanionRegClientUtils"), ...window.require("WAWebAdvSignatureApi"), ...window.require("WAWebUserPrefsInfoStore"), ...window.require("WAWebSignalStoreApi") } } function K() { window.SWA_Store = Object.assign({}, window.require("WAWebCollections")), window.SWA_Store.AppState = window.require("WAWebSocketModel").Socket, window.SWA_Store.Conn = window.require("WAWebConnModel").Conn, window.SWA_Store.Cmd = window.require("WAWebCmd").Cmd, window.SWA_Store.MediaPrep = window.require("WAWebPrepRawMedia"), window.SWA_Store.MediaObject = window.require("WAWebMediaStorage"), window.SWA_Store.MediaTypes = window.require("WAWebMmsMediaTypes"), window.SWA_Store.MediaUpload = window.require("WAWebMediaMmsV4Upload"), window.SWA_Store.MsgKey = window.require("WAWebMsgKey"), window.SWA_Store.NumberInfo = window.require("WAPhoneUtils"), window.SWA_Store.PhoneFindCC = window.require("WAPhoneFindCC"), window.SWA_Store.OpaqueData = window.require("WAWebMediaOpaqueData"), window.SWA_Store.SendMessage = window.require("WAWebSendMsgChatAction"), window.SWA_Store.EditMessage = window.require("WAWebSendMessageEditAction"), window.SWA_Store.SendSeen = window.require("WAWebUpdateUnreadChatAction"), window.SWA_Store.User = window.require("WAWebUserPrefsMeUser"), window.SWA_Store.ContactMethods = window.require("WAWebContactGetters"), window.SWA_Store.UploadUtils = window.require("WAWebUploadManager"), window.SWA_Store.UserConstructor = window.require("WAWebWid"), window.SWA_Store.Validators = window.require("WALinkify"), window.SWA_Store.VCard = window.require("WAWebFrontendVcardUtils"), window.SWA_Store.WidFactory = window.require("WAWebWidFactory"), window.SWA_Store.ChatState = window.require("WAWebChatStateBridge"), window.SWA_Store.findCommonGroups = window.require("WAWebFindCommonGroupsContactAction").findCommonGroups, window.SWA_Store.ConversationMsgs = window.require("WAWebChatLoadMessages"), window.SWA_Store.createOrUpdateReactionsModule = window.require("WAWebDBCreateOrUpdateReactions"), window.SWA_Store.EphemeralFields = window.require("WAWebGetEphemeralFieldsMsgActionsUtils"), window.SWA_Store.MsgActionChecks = window.require("WAWebMsgActionCapability"), window.SWA_Store.QuotedMsg = window.require("WAWebQuotedMsgModelUtils"), window.SWA_Store.LinkPreview = window.require("WAWebLinkPreviewChatAction"), window.SWA_Store.SearchContext = window.require("WAWebChatMessageSearch").getSearchContext, window.SWA_Store.getMsgInfo = window.require("WAWebApiMessageInfoStore").queryMsgInfo, window.SWA_Store.QueryExist = window.require("WAWebQueryExistsJob").queryWidExists, window.SWA_Store.QueryExistJob = window.require("WAWebQueryExistsJob"), window.SWA_Store.PhoneNumberFormatUtils = window.require("WAWebLinkDevicePhoneNumberEntryInputFormatUtils"), window.SWA_Store.ReplyUtils = window.require("WAWebMsgReply"), window.SWA_Store.HistorySync = window.require("WAWebSendNonMessageDataRequest"), window.SWA_Store.Lid1X1MigrationGating = window.require("WAWebLid1X1MigrationGating"), window.SWA_Store.StickerTools = { ...window.require("WAWebImageUtils"), ...window.require("WAWebAddWebpMetadata") }, window.SWA_Store.GroupParticipants = { ...window.require("WAWebModifyParticipantsGroupAction"), ...window.require("WASmaxGroupsAddParticipantsRPC") }, window.SWA_Store.Chat._find && window.SWA_Store.Chat.findImpl || (window.SWA_Store.Chat._find = e => { const t = window.SWA_Store.Chat.get(e); return t ? Promise.resolve(t) : Promise.resolve({ id: e }) }, window.SWA_Store.Chat.findImpl = window.SWA_Store.Chat._find), window.injectToFunction = (e, t) => { const i = window.require(e.module), n = i[e.function]; i[e.function] = (...e) => t(n, ...e) }, window.injectToFunction({ module: "WAWebBackendJobsCommon", function: "mediaTypeFromProtobuf" }, ((e, ...t) => { const [i] = t; return i.locationMessage ? null : e(...t) })), window.injectToFunction({ module: "WAWebE2EProtoUtils", function: "typeAttributeFromProtobuf" }, ((e, ...t) => { const [i] = t; return i.locationMessage || i.groupInviteMessage ? "text" : e(...t) })) } function H() { window.WWebJS = {}, window.WWebJS.sendSeen = async e => { let t = window.SWA_Store.Chat.get(e); return void 0 !== t && (await window.SWA_Store.SendSeen.sendSeen(t, !1), !0) }, window.WWebJS.sendMessage = async (e, t, i = {}) => { var n, a, o; let r = {}; i.attachment && (r = i.sendMediaAsSticker ? await window.WWebJS.processStickerData(i.attachment) : await window.WWebJS.processMediaData(i.attachment, { forceVoice: i.sendAudioAsVoice, forceDocument: i.sendMediaAsDocument, forceGif: i.sendVideoAsGif }), r.caption = i.caption, t = i.sendMediaAsSticker ? void 0 : r.preview, r.isViewOnce = i.isViewOnce, delete i.attachment, delete i.sendMediaAsSticker); let s = {}; if (i.quotedMessageId) { let t = window.SWA_Store.Msg.get(i.quotedMessageId); (window.SWA_Store.ReplyUtils ? window.SWA_Store.ReplyUtils.canReplyMsg(t.unsafe()) : t.canReply()) && (s = t.msgContextInfo(e)), delete i.quotedMessageId } i.mentionedJidList && (i.mentionedJidList = await Promise.all(i.mentionedJidList.map((async e => { const t = window.SWA_Store.WidFactory.createWid(e); if (await window.SWA_Store.QueryExist(t)) return t }))), i.mentionedJidList = i.mentionedJidList.filter(Boolean)), i.groupMentions && (i.groupMentions = i.groupMentions.map((e => ({ groupSubject: e.subject, groupJid: window.SWA_Store.WidFactory.createWid(e.id) })))); let d = {}; if (i.location) { let { latitude: e, longitude: t, description: o, url: r } = i.location; r = null == (a = null == (n = window.SWA_Store.Validators) ? void 0 : n.findLink(r)) ? void 0 : a.href, r && !o && (o = r), d = { type: "location", loc: o, lat: e, lng: t, clientUrl: r }, delete i.location } let c = {}; if (i.poll) { const { pollName: e, pollOptions: t } = i.poll, { allowMultipleAnswers: n, messageSecret: a } = i.poll.options; c = { type: "poll_creation", pollName: e, pollOptions: t, pollSelectableOptionsCount: n ? 0 : 1, messageSecret: Array.isArray(a) && 32 === a.length ? new Uint8Array(a) : window.crypto.getRandomValues(new Uint8Array(32)) }, delete i.poll } let u = {}; if (i.contactCard) { let e = window.SWA_Store.Contact.get(i.contactCard); u = { body: window.SWA_Store.VCard.vcardFromContactModel(e).vcard, type: "vcard", vcardFormattedName: e.formattedName }, delete i.contactCard } else if (i.contactCardList) { u = { type: "multi_vcard", vcardList: i.contactCardList.map((e => window.SWA_Store.Contact.get(e))).map((e => window.SWA_Store.VCard.vcardFromContactModel(e))), body: void 0 }, delete i.contactCardList } else if (i.parseVCards && "string" == typeof t && t.startsWith("BEGIN:VCARD")) { delete i.parseVCards; try { const e = window.SWA_Store.VCard.parseVcard(t); e && (u = { type: "vcard", vcardFormattedName: window.SWA_Store.VCard.vcardGetNameFromParsed(e) }) } catch (y) { } } if (i.linkPreview) { delete i.linkPreview; const e = null == (o = window.SWA_Store.Validators) ? void 0 : o.findLink(t); if (e) { let t = await window.SWA_Store.LinkPreview.getLinkPreview(e); t && t.data && (t = t.data, t.preview = !0, t.subtype = "url", i = { ...i, ...t }) } } let l = {}; if (i.buttons) { let e; e = "chat" === i.buttons.type ? t = i.buttons.body : i.caption ? i.caption : " ", l = { productHeaderImageRejected: !1, isFromTemplate: !1, isDynamicReplyButtonsMsg: !0, title: i.buttons.title ? i.buttons.title : void 0, footer: i.buttons.footer ? i.buttons.footer : void 0, dynamicReplyButtons: i.buttons.buttons, replyButtons: i.buttons.buttons, caption: e }, delete i.buttons } let p = {}; if (i.list) { if ("smba" === window.SWA_Store.Conn.platform || "smbi" === window.SWA_Store.Conn.platform) throw "[LT01] Whatsapp business can't send this yet"; p = { type: "list", footer: i.list.footer, list: { ...i.list, listType: 1 }, body: i.list.description }, delete i.list, delete p.list.footer } const h = window.SWA_Store.User.getMaybeMePnUser(), w = await window.SWA_Store.MsgKey.newId(), m = new window.SWA_Store.MsgKey({ from: h, to: e.id, id: w, participant: e.id.isGroup() ? h : void 0, selfDir: "out" }), f = i.extraOptions || {}; delete i.extraOptions; const g = window.SWA_Store.EphemeralFields.getEphemeralFields(e), S = { ...i, id: m, ack: 0, body: t, from: h, to: e.id, local: !0, self: "out", t: parseInt((new Date).getTime() / 1e3), isNewMsg: !0, type: "chat", ...g, ...d, ...c, ...r, ...r.toJSON ? r.toJSON() : {}, ...s, ...u, ...l, ...p, ...f }; return await window.SWA_Store.SendMessage.addAndSendMsgToChat(e, S), await window.SWA_Store.HistorySync.sendPeerDataOperationRequest(3, { chatId: e.id }), window.SWA_Store.Msg.get(m._serialized) }, window.WWebJS.editMessage = async (e, t, i = {}) => { var n; const a = i.extraOptions || {}; if (delete i.extraOptions, i.mentionedJidList && (i.mentionedJidList = await Promise.all(i.mentionedJidList.map((async e => { const t = window.SWA_Store.WidFactory.createWid(e); if (await window.SWA_Store.QueryExist(t)) return t }))), i.mentionedJidList = i.mentionedJidList.filter(Boolean)), i.groupMentions && (i.groupMentions = i.groupMentions.map((e => ({ groupSubject: e.subject, groupJid: window.SWA_Store.WidFactory.createWid(e.id) })))), i.linkPreview) { delete i.linkPreview; const e = null == (n = window.SWA_Store.Validators) ? void 0 : n.findLink(t); if (e) { const t = await window.SWA_Store.LinkPreview.getLinkPreview(e); t.preview = !0, t.subtype = "url", i = { ...i, ...t } } } const o = { ...i, ...a }; return await window.SWA_Store.EditMessage.sendMessageEdit(e, t, o), window.SWA_Store.Msg.get(e.id._serialized) }, window.WWebJS.toStickerData = async e => { if ("image/webp" == e.mimetype) return e; const t = window.WWebJS.mediaInfoToFile(e), i = await window.SWA_Store.StickerTools.toWebpSticker(t), n = await i.arrayBuffer(); return { mimetype: "image/webp", data: window.WWebJS.arrayBufferToBase64(n) } }, window.WWebJS.processStickerData = async e => { if ("image/webp" !== e.mimetype) throw new Error("Invalid media type"); const t = window.WWebJS.mediaInfoToFile(e); let i = await window.WWebJS.getFileHash(t), n = await window.WWebJS.generateHash(32); const a = new AbortController, o = await window.SWA_Store.UploadUtils.encryptAndUpload({ blob: t, type: "sticker", signal: a.signal, mediaKey: n }); return { ...o, clientUrl: o.url, deprecatedMms3Url: o.url, uploadhash: o.encFilehash, size: t.size, type: "sticker", filehash: i } }, window.WWebJS.processMediaData = async (e, { forceVoice: t, forceDocument: i, forceGif: n }) => { const a = window.WWebJS.mediaInfoToFile(e), o = await window.SWA_Store.OpaqueData.createFromData(a, a.type), r = window.SWA_Store.MediaPrep.prepRawMedia(o, { asDocument: i }), s = await r.waitForPrep(), d = window.SWA_Store.MediaObject.getOrCreateMediaObject(s.filehash), c = window.SWA_Store.MediaTypes.msgToMediaType({ type: s.type, isGif: s.isGif }); if (t && "audio" === s.type) { s.type = "ptt"; const e = d.contentInfo.waveform; s.waveform = e ?? await window.WWebJS.generateWaveform(a) } n && "video" === s.type && (s.isGif = !0), i && (s.type = "document"), s.mediaBlob instanceof window.SWA_Store.OpaqueData || (s.mediaBlob = await window.SWA_Store.OpaqueData.createFromData(s.mediaBlob, s.mediaBlob.type)), s.renderableUrl = s.mediaBlob.url(), d.consolidate(s.toJSON()), s.mediaBlob.autorelease(); const u = (await window.SWA_Store.MediaUpload.uploadMedia({ mimetype: s.mimetype, mediaObject: d, mediaType: c })).mediaEntry; if (!u) throw new Error("upload failed: media entry was not created"); return s.set({ clientUrl: u.mmsUrl, deprecatedMms3Url: u.deprecatedMms3Url, directPath: u.directPath, mediaKey: u.mediaKey, mediaKeyTimestamp: u.mediaKeyTimestamp, filehash: d.filehash, encFilehash: u.encFilehash, uploadhash: u.uploadHash, size: d.size, streamingSidecar: u.sidecar, firstFrameSidecar: u.firstFrameSidecar }), s }, window.WWebJS.getMessageModel = e => { var t; const i = e.serialize(); return i.isEphemeral = e.isEphemeral, i.isStatusV3 = e.isStatusV3, i.links = (null == (t = window.SWA_Store.Validators) ? void 0 : t.findLinks(e.mediaObject ? e.caption : e.body)).map((e => ({ link: e.href, isSuspicious: Boolean(e.suspiciousCharacters && e.suspiciousCharacters.size) }))), i.buttons && (i.buttons = i.buttons.serialize()), i.dynamicReplyButtons && (i.dynamicReplyButtons = JSON.parse(JSON.stringify(i.dynamicReplyButtons))), i.replyButtons && (i.replyButtons = JSON.parse(JSON.stringify(i.replyButtons))), "object" == typeof i.id.remote && (i.id = Object.assign({}, i.id, { remote: i.id.remote._serialized })), delete i.pendingAckUpdate, i }, window.WWebJS.getChatModel = async e => { let t = e.serialize(); if (t.isGroup = !1, t.formattedTitle = e.formattedTitle, t.isMuted = 0 != e.muteExpiration, e.groupMetadata) { t.isGroup = !0; const i = window.SWA_Store.WidFactory.createWid(e.id._serialized); await window.SWA_Store.GroupMetadata.update(i), e.groupMetadata.participants._models.filter((e => e.id._serialized.endsWith("@lid"))).forEach((e => { var t; e.id = null == (t = e.contact) ? void 0 : t.phoneNumber })), t.groupMetadata = e.groupMetadata.serialize() } if (t.lastMessage = null, t.msgs && t.msgs.length) { const i = e.lastReceivedKey ? window.SWA_Store.Msg.get(e.lastReceivedKey._serialized) : null; i && (t.lastMessage = window.WWebJS.getMessageModel(i)) } return delete t.msgs, delete t.msgUnsyncedButtonReplyMsgs, delete t.unsyncedButtonReplies, t }, window.WWebJS.getChat = async e => { const t = window.SWA_Store.WidFactory.createWid(e), i = await window.SWA_Store.Chat.find(t); let n = await window.WWebJS.getChatModel(i); return console.log("res>>> getChat", n), n }, window.WWebJS.getChats = async () => { const e = window.SWA_Store.Chat.getModelsArray().map((e => window.WWebJS.getChatModel(e))); return await Promise.all(e) }, window.WWebJS.getContactModel = e => { let t = e.serialize(); t.isBusiness = void 0 !== e.isBusiness && e.isBusiness, e.businessProfile && (t.businessProfile = e.businessProfile.serialize()); const i = window.WWebJS.compareWwebVersions(window.Debug.VERSION, "<", "2.2327.4"); return t.isMe = i ? e.isMe : window.SWA_Store.ContactMethods.getIsMe(e), t.isUser = i ? e.isUser : window.SWA_Store.ContactMethods.getIsUser(e), t.isGroup = i ? e.isGroup : window.SWA_Store.ContactMethods.getIsGroup(e), t.isWAContact = i ? e.isWAContact : window.SWA_Store.ContactMethods.getIsWAContact(e), t.isMyContact = i ? e.isMyContact : window.SWA_Store.ContactMethods.getIsMyContact(e), t.isBlocked = e.isContactBlocked, t.userid = i ? e.userid : window.SWA_Store.ContactMethods.getUserid(e), t.isEnterprise = i ? e.isEnterprise : window.SWA_Store.ContactMethods.getIsEnterprise(e), t.verifiedName = i ? e.verifiedName : window.SWA_Store.ContactMethods.getVerifiedName(e), t.verifiedLevel = i ? e.verifiedLevel : window.SWA_Store.ContactMethods.getVerifiedLevel(e), t.statusMute = i ? e.statusMute : window.SWA_Store.ContactMethods.getStatusMute(e), t.name = i ? e.name : window.SWA_Store.ContactMethods.getName(e), t.shortName = i ? e.shortName : window.SWA_Store.ContactMethods.getShortName(e), t.pushname = i ? e.pushname : window.SWA_Store.ContactMethods.getPushname(e), t }, window.WWebJS.getContact = async e => { const t = window.SWA_Store.WidFactory.createWid(e); let i = await window.SWA_Store.Contact.find(t); i.id._serialized.endsWith("@lid") && (i.id = null == i ? void 0 : i.phoneNumber); const n = await window.SWA_Store.BusinessProfile.fetchBizProfile(t); return n.profileOptions && (i.businessProfile = n), window.WWebJS.getContactModel(i) }, window.WWebJS.getContacts = () => window.SWA_Store.Contact.getModelsArray().map((e => window.WWebJS.getContactModel(e))), window.WWebJS.mediaInfoToFile = ({ data: e, mimetype: t, filename: i }) => { const n = window.atob(e), a = new ArrayBuffer(n.length), o = new Uint8Array(a); for (let s = 0; s < n.length; s++)o[s] = n.charCodeAt(s); const r = new Blob([a], { type: t }); return new File([r], i, { type: t, lastModified: Date.now() }) }, window.WWebJS.arrayBufferToBase64 = e => { let t = ""; const i = new Uint8Array(e), n = i.byteLength; for (let a = 0; a < n; a++)t += String.fromCharCode(i[a]); return window.btoa(t) }, window.WWebJS.arrayBufferToBase64Async = e => new Promise(((t, i) => { const n = new Blob([e], { type: "application/octet-stream" }), a = new FileReader; a.onload = () => { const [, e] = a.result.split(","); t(e) }, a.onerror = e => i(e), a.readAsDataURL(n) })), window.WWebJS.getFileHash = async e => { let t = await e.arrayBuffer(); const i = await crypto.subtle.digest("SHA-256", t); return btoa(String.fromCharCode(...new Uint8Array(i))) }, window.WWebJS.generateHash = async e => { for (var t = "", i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = 0; n < e; n++)t += i.charAt(Math.floor(62 * Math.random())); return t }, window.WWebJS.generateWaveform = async e => { try { const t = await e.arrayBuffer(), i = new AudioContext, n = (await i.decodeAudioData(t)).getChannelData(0), a = 64, o = Math.floor(n.length / a), r = []; for (let e = 0; e < a; e++) { const t = o * e; let i = 0; for (let e = 0; e < o; e++)i += Math.abs(n[t + e]); r.push(i / o) } const s = Math.pow(Math.max(...r), -1), d = r.map((e => e * s)); return new Uint8Array(d.map((e => Math.floor(100 * e)))) } catch (t) { return } }, window.WWebJS.sendChatstate = async (e, t) => { switch (t = window.SWA_Store.WidFactory.createWid(t), e) { case "typing": await window.SWA_Store.ChatState.sendChatStateComposing(t); break; case "recording": await window.SWA_Store.ChatState.sendChatStateRecording(t); break; case "stop": await window.SWA_Store.ChatState.sendChatStatePaused(t); break; default: throw "Invalid chatstate" }return !0 }, window.WWebJS.getLabelModel = e => { let t = e.serialize(); return t.hexColor = e.hexColor, t }, window.WWebJS.getLabels = () => window.SWA_Store.Label.getModelsArray().map((e => window.WWebJS.getLabelModel(e))), window.WWebJS.getLabel = e => { const t = window.SWA_Store.Label.get(e); return window.WWebJS.getLabelModel(t) }, window.WWebJS.getChatLabels = async e => ((await window.WWebJS.getChat(e)).labels || []).map((e => window.WWebJS.getLabel(e))), window.WWebJS.cropAndResizeImage = async (e, t = {}) => { if (!e.mimetype.includes("image")) throw new Error("Media is not an image"); t.mimetype && !t.mimetype.includes("image") && delete t.mimetype, t = Object.assign({ size: 640, mimetype: e.mimetype, quality: .75, asDataUrl: !1 }, t); const i = await new Promise(((t, i) => { const n = new Image; n.onload = () => t(n), n.onerror = i, n.src = `data:${e.mimetype};base64,${e.data}` })), n = Math.min(i.width, i.height), a = Math.floor((i.width - n) / 2), o = Math.floor((i.height - n) / 2), r = document.createElement("canvas"); r.width = t.size, r.height = t.size; r.getContext("2d").drawImage(i, a, o, n, n, 0, 0, t.size, t.size); const s = r.toDataURL(t.mimetype, t.quality); return t.asDataUrl ? s : Object.assign(e, { mimetype: t.mimeType, data: s.replace(`data:${t.mimeType};base64,`, "") }) }, window.WWebJS.compareWwebVersions = (e, t, i) => { if (![">", ">=", "<", "<=", "="].includes(t)) throw new class extends Error { constructor(e) { super(e), this.name = "CompareWwebVersionsError" } }("Invalid comparison operator is provided"); if ("string" != typeof e || "string" != typeof i) throw new class extends Error { constructor(e) { super(e), this.name = "CompareWwebVersionsError" } }("A non-string WWeb version type is provided"); for (e = e.replace(/-beta$/, ""), i = i.replace(/-beta$/, ""); e.length !== i.length;)e.length > i.length ? i = i.concat("0") : e = e.concat("0"); return e = Number(e.replace(/\./g, "")), i = Number(i.replace(/\./g, "")), ">" === t ? e > i : ">=" === t ? e >= i : "<" === t ? e < i : "<=" === t ? e <= i : "=" === t && e === i } } class $ { constructor(e) { Object.defineProperty(this, "client", { value: e }) } _clone() { return Object.assign(Object.create(this), this) } _patch(e) { return e } } class Q { constructor(e, t, i, n) { this.mimetype = e, this.data = t, this.filename = i, this.filesize = n } } class X { constructor(e, t, i = {}) { this.latitude = e, this.longitude = t, this.name = i.name, this.address = i.address, this.url = i.url, this.description = this.name && this.address ? `${this.name}\n${this.address}` : this.name || this.address || "" } } class Y extends $ { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.id, this.retailer_id = e.retailer_id, this.name = e.name, this.description = e.description, super._patch(e) } } class Z extends $ { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.id, this.price = e.price ? e.price : "", this.thumbnailUrl = e.thumbnailUrl, this.currency = e.currency, this.name = e.name, this.quantity = e.quantity, this.data = null, super._patch(e) } async getData() { if (null === this.data) { let e = await this.client.pupPage.evaluate((e => window.WWebJS.getProductMetadata(e)), this.id); this.data = e ? new Y(this.client, e) : void 0 } return this.data } } class ee extends $ { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return e.products && (this.products = e.products.map((e => new Z(this.client, e)))), this.subtotal = e.subtotal, this.total = e.total, this.currency = e.currency, this.createdAt = e.createdAt, super._patch(e) } } class te extends $ { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.id, this.paymentCurrency = e.paymentCurrency, this.paymentAmount1000 = e.paymentAmount1000, this.paymentMessageReceiverJid = e.paymentMessageReceiverJid, this.paymentTransactionTimestamp = e.paymentTransactionTimestamp, this.paymentStatus = e.paymentStatus, this.paymentTxnStatus = e.paymentTxnStatus, this.paymentNote = e.paymentNoteMsg && e.paymentNoteMsg.body ? e.paymentNoteMsg.body : void 0, super._patch(e) } } class ie extends $ { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.msgKey, this.orphan = e.orphan, this.orphanReason = e.orphanReason, this.timestamp = e.timestamp, this.reaction = e.reactionText, this.read = e.read, this.msgId = e.parentMsgKey, this.senderId = e.senderUserJid, this.ack = e.ack, super._patch(e) } } class ne extends $ { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.id, this.number = e.userid, this.isBusiness = e.isBusiness, this.isEnterprise = e.isEnterprise, this.labels = e.labels, this.name = e.name, this.pushname = e.pushname, this.sectionHeader = e.sectionHeader, this.shortName = e.shortName, this.statusMute = e.statusMute, this.type = e.type, this.verifiedLevel = e.verifiedLevel, this.verifiedName = e.verifiedName, this.isMe = e.isMe, this.isUser = e.isUser, this.isGroup = e.isGroup, this.isWAContact = e.isWAContact, this.isMyContact = e.isMyContact, this.isBlocked = e.isBlocked, super._patch(e) } async getProfilePicUrl() { return await this.client.getProfilePicUrl(this.id._serialized) } async getFormattedNumber() { return await this.client.getFormattedNumber(this.id._serialized) } async getCountryCode() { return await this.client.getCountryCode(this.id._serialized) } async getChat() { return this.isMe ? null : await this.client.getChatById(this.id._serialized) } async getCommonGroups() { return await this.client.getCommonGroups(this.id._serialized) } } class ae extends $ { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this._data = e, this.mediaKey = e.mediaKey, this.id = e.id, this.ack = e.ack, this.hasMedia = Boolean(e.mediaKey && e.directPath), this.body = this.hasMedia ? e.caption || "" : e.body || e.pollName || "", this.type = e.type, this.timestamp = e.t, this.from = "object" == typeof e.from && null !== e.from ? e.from._serialized : e.from, this.to = "object" == typeof e.to && null !== e.to ? e.to._serialized : e.to, this.author = "object" == typeof e.author && null !== e.author ? e.author._serialized : e.author, this.deviceType = "string" == typeof e.id.id && e.id.id.length > 21 ? "android" : "string" == typeof e.id.id && "3A" === e.id.id.substring(0, 2) ? "ios" : "web", this.isForwarded = e.isForwarded, this.forwardingScore = e.forwardingScore || 0, this.isStatus = e.isStatusV3 || "status@broadcast" === e.id.remote, this.isStarred = e.star, this.broadcast = e.broadcast, this.fromMe = e.id.fromMe, this.hasQuotedMsg = !!e.quotedMsg, this.hasReaction = !!e.hasReaction, this.duration = e.duration ? e.duration : void 0, this.location = (() => { if (e.type !== x) return; let t; if (e.loc && "string" == typeof e.loc) { let i = e.loc.split("\n"); t = { name: i[0], address: i[1], url: e.clientUrl } } return new X(e.lat, e.lng, t) })(), this.vCards = e.type === F ? e.vcardList.map((e => e.vcard)) : e.type === I ? [e.body] : [], this.inviteV4 = e.type === U ? { inviteCode: e.inviteCode, inviteCodeExp: e.inviteCodeExp, groupId: e.inviteGrp, groupName: e.inviteGrpName, fromId: "_serialized" in e.from ? e.from._serialized : e.from, toId: "_serialized" in e.to ? e.to._serialized : e.to } : void 0, this.mentionedIds = e.mentionedJidList || [], this.groupMentions = e.groupMentions || [], this.orderId = e.orderId ? e.orderId : void 0, this.token = e.token ? e.token : void 0, this.isGif = Boolean(e.isGif), this.isEphemeral = e.isEphemeral, e.title && (this.title = e.title), e.description && (this.description = e.description), e.businessOwnerJid && (this.businessOwnerJid = e.businessOwnerJid), e.productId && (this.productId = e.productId), e.latestEditSenderTimestampMs && (this.latestEditSenderTimestampMs = e.latestEditSenderTimestampMs), e.latestEditMsgKey && (this.latestEditMsgKey = e.latestEditMsgKey), this.links = e.links, e.dynamicReplyButtons && (this.dynamicReplyButtons = e.dynamicReplyButtons), e.selectedButtonId && (this.selectedButtonId = e.selectedButtonId), e.listResponse && e.listResponse.singleSelectReply.selectedRowId && (this.selectedRowId = e.listResponse.singleSelectReply.selectedRowId), this.type === q && (this.pollName = e.pollName, this.pollOptions = e.pollOptions, this.allowMultipleAnswers = Boolean(!e.pollSelectableOptionsCount), this.pollInvalidated = e.pollInvalidated, this.isSentCagPollCreation = e.isSentCagPollCreation, delete this._data.pollName, delete this._data.pollOptions, delete this._data.pollSelectableOptionsCount, delete this._data.pollInvalidated, delete this._data.isSentCagPollCreation), super._patch(e) } _getChatId() { return this.fromMe ? this.to : this.from } async reload() { const e = await this.client.pupPage.evaluate((e => { const t = window.SWA_Store.Msg.get(e); return t ? window.WWebJS.getMessageModel(t) : null }), this.id._serialized); return e ? (this._patch(e), this) : null } get rawData() { return this._data } getChat() { return this.client.getChatById(this._getChatId()) } getContact() { return this.client.getContactById(this.author || this.from) } async getMentions() { return await Promise.all(this.mentionedIds.map((async e => await this.client.getContactById(e)))) } async getGroupMentions() { return await Promise.all(this.groupMentions.map((async e => await this.client.getChatById(e.groupJid._serialized)))) } async getQuotedMessage() { if (!this.hasQuotedMsg) return; const e = await this.client.pupPage.evaluate((e => { const t = window.SWA_Store.Msg.get(e), i = window.SWA_Store.QuotedMsg.getQuotedMsgObj(t); return window.WWebJS.getMessageModel(i) }), this.id._serialized); return new ae(this.client, e) } async reply(e, t, i = {}) { return t || (t = this._getChatId()), i = { ...i, quotedMessageId: this.id._serialized }, this.client.sendMessage(t, e, i) } async acceptGroupV4Invite() { return await this.client.acceptGroupV4Invite(this.inviteV4) } async delete(e) { await this.client.pupPage.evaluate((async (e, t) => { let i = window.SWA_Store.Msg.get(e), n = await window.SWA_Store.Chat.find(i.id.remote); const a = window.SWA_Store.MsgActionChecks.canSenderRevokeMsg(i) || window.SWA_Store.MsgActionChecks.canAdminRevokeMsg(i); return t && a ? window.SWA_Store.Cmd.sendRevokeMsgs(n, [i], { clearMedia: !0, type: i.id.fromMe ? "Sender" : "Admin" }) : window.SWA_Store.Cmd.sendDeleteMsgs(n, [i], !0) }), this.id._serialized, e) } async star() { await this.client.pupPage.evaluate((async e => { let t = window.SWA_Store.Msg.get(e); if (window.SWA_Store.MsgActionChecks.canStarMsg(t)) { let e = await window.SWA_Store.Chat.find(t.id.remote); return window.SWA_Store.Cmd.sendStarMsgs(e, [t], !1) } }), this.id._serialized) } async unstar() { await this.client.pupPage.evaluate((async e => { let t = window.SWA_Store.Msg.get(e); if (window.SWA_Store.MsgActionChecks.canStarMsg(t)) { let e = await window.SWA_Store.Chat.find(t.id.remote); return window.SWA_Store.Cmd.sendUnstarMsgs(e, [t], !1) } }), this.id._serialized) } async getInfo() { return await this.client.pupPage.evaluate((async e => { const t = window.SWA_Store.Msg.get(e); return t && t.id.fromMe ? new Promise((e => { setTimeout((async () => { e(await window.SWA_Store.getMsgInfo(t.id)) }), Date.now() - 1e3 * t.t < 1250 && Math.floor(101 * Math.random()) + 1100 || 0) })) : null }), this.id._serialized) } async getOrder() { if (this.type === N) { const e = await this.client.pupPage.evaluate(((e, t, i) => window.WWebJS.getOrderDetail(e, t, i)), this.orderId, this.token, this._getChatId()); if (!e) return; return new ee(this.client, e) } } async getPayment() { if (this.type === B) { const e = await this.client.pupPage.evaluate((async e => { const t = window.SWA_Store.Msg.get(e); return t ? t.serialize() : null }), this.id._serialized); return new te(this.client, e) } } async getReactions() { if (!this.hasReaction) return; const e = await this.client.pupPage.evaluate((async e => { const t = await window.SWA_Store.Reactions.find(e); return t && t.reactions.length ? t.reactions.serialize() : null }), this.id._serialized); return e ? e.map((e => (e.senders = e.senders.map((e => (e.timestamp = Math.round(e.timestamp / 1e3), new ie(this.client, e)))), e))) : void 0 } async edit(e, t = {}) { t.mentions && (!Array.isArray(t.mentions) && (t.mentions = [t.mentions]), t.mentions.some((e => e instanceof ne)) && (console.warn("Mentions with an array of Contact are now deprecated. See more at https://github.com/pedroslopez/whatsapp-web.js/pull/2166."), t.mentions = t.mentions.map((e => e.id._serialized)))), t.groupMentions && !Array.isArray(t.groupMentions) && (t.groupMentions = [t.groupMentions]); let i = { linkPreview: !1 !== t.linkPreview || void 0, mentionedJidList: t.mentions || [], groupMentions: t.groupMentions, extraOptions: t.extra }; if (!this.fromMe) return null; const n = await this.client.pupPage.evaluate((async (e, t, i) => { let n = window.SWA_Store.Msg.get(e); if (!n) return null; if (window.SWA_Store.MsgActionChecks.canEditText(n) || window.SWA_Store.MsgActionChecks.canEditCaption(n)) { return (await window.WWebJS.editMessage(n, t, i)).serialize() } return null }), this.id._serialized, e, i); return n ? new ae(this.client, n) : null } } class oe extends $ { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.id, this.name = e.formattedTitle, this.isGroup = e.isGroup, this.isReadOnly = e.isReadOnly, this.unreadCount = e.unreadCount, this.timestamp = e.t, this.archived = e.archive, this.pinned = !!e.pin, this.isMuted = e.isMuted, this.muteExpiration = e.muteExpiration, this.lastMessage = e.lastMessage ? new ae(super.client, e.lastMessage) : void 0, super._patch(e) } async sendMessage(e, t) { return this.client.sendMessage(this.id._serialized, e, t) } async sendSeen() { return this.client.sendSeen(this.id._serialized) } async archive() { return this.client.archiveChat(this.id._serialized) } async unarchive() { return this.client.unarchiveChat(this.id._serialized) } async pin() { return this.client.pinChat(this.id._serialized) } async unpin() { return this.client.unpinChat(this.id._serialized) } async mute(e) { return this.client.muteChat(this.id._serialized, e) } async unmute() { return this.client.unmuteChat(this.id._serialized) } async markUnread() { return this.client.markChatUnread(this.id._serialized) } async fetchMessages(e) { return (await this.client.pupPage.evaluate((async (e, t) => { const i = e => !e.isNotification && (!t || void 0 === t.fromMe || e.id.fromMe === t.fromMe), n = window.SWA_Store.Chat.get(e); let a = n.msgs.getModelsArray().filter(i); if (t && t.limit > 0) { for (; a.length < t.limit;) { const e = await window.SWA_Store.ConversationMsgs.loadEarlierMsgs(n); if (!e || !e.length) break; a = [...e.filter(i), ...a] } a.length > t.limit && (a.sort(((e, t) => e.t > t.t ? 1 : -1)), a = a.splice(a.length - t.limit)) } return a.map((e => window.WWebJS.getMessageModel(e))) }), this.id._serialized, e)).map((e => new ae(this.client, e))) } async sendStateTyping() { return this.client.pupPage.evaluate((e => (window.WWebJS.sendChatstate("typing", e), !0)), this.id._serialized) } async sendStateRecording() { return this.client.pupPage.evaluate((e => (window.WWebJS.sendChatstate("recording", e), !0)), this.id._serialized) } async clearState() { return this.client.pupPage.evaluate((e => (window.WWebJS.sendChatstate("stop", e), !0)), this.id._serialized) } async getContact() { return await this.client.getContactById(this.id._serialized) } async getLabels() { return this.client.getChatLabels(this.id._serialized) } async changeLabels(e) { return this.client.addOrRemoveLabels(e, [this.id._serialized]) } } class re extends oe { } class se extends oe { _patch(e) { return this.groupMetadata = e.groupMetadata, super._patch(e) } get owner() { return this.groupMetadata.owner } get createdAt() { return new Date(1e3 * this.groupMetadata.creation) } get description() { return this.groupMetadata.desc } get participants() { return this.groupMetadata.participants } async removeParticipants(e) { return await this.client.pupPage.evaluate((async (e, t) => { const i = window.SWA_Store.WidFactory.createWid(e), n = await window.SWA_Store.Chat.find(i), a = t.map((e => n.groupMetadata.participants.get(e))).filter((e => Boolean(e))); return await window.SWA_Store.GroupParticipants.removeParticipants(n, a), { status: 200 } }), this.id._serialized, e) } async promoteParticipants(e) { return await this.client.pupPage.evaluate((async (e, t) => { const i = window.SWA_Store.WidFactory.createWid(e), n = await window.SWA_Store.Chat.find(i), a = t.map((e => n.groupMetadata.participants.get(e))).filter((e => Boolean(e))); return await window.SWA_Store.GroupParticipants.promoteParticipants(n, a), { status: 200 } }), this.id._serialized, e) } async demoteParticipants(e) { return await this.client.pupPage.evaluate((async (e, t) => { const i = window.SWA_Store.WidFactory.createWid(e), n = await window.SWA_Store.Chat.find(i), a = t.map((e => n.groupMetadata.participants.get(e))).filter((e => Boolean(e))); return await window.SWA_Store.GroupParticipants.demoteParticipants(n, a), { status: 200 } }), this.id._serialized, e) } async deletePicture() { return await this.client.pupPage.evaluate((e => window.WWebJS.deletePicture(e)), this.id._serialized) } async setPicture(e) { return await this.client.pupPage.evaluate(((e, t) => window.WWebJS.setPicture(e, t)), this.id._serialized, e) } async getInviteCode() { return (await this.client.pupPage.evaluate((async e => { const t = window.SWA_Store.WidFactory.createWid(e); return window.SWA_Store.GroupInvite.queryGroupInviteCode(t) }), this.id._serialized)).code } async revokeInvite() { return (await this.client.pupPage.evaluate((e => { const t = window.SWA_Store.WidFactory.createWid(e); return window.SWA_Store.GroupInvite.resetGroupInviteCode(t) }), this.id._serialized)).code } async getGroupMembershipRequests() { return await this.client.getGroupMembershipRequests(this.id._serialized) } async approveGroupMembershipRequests(e = {}) { return await this.client.approveGroupMembershipRequests(this.id._serialized, e) } async rejectGroupMembershipRequests(e = {}) { return await this.client.rejectGroupMembershipRequests(this.id._serialized, e) } } const de = class { static create(e, t) { return t.isGroup ? new se(e, t) : new re(e, t) } }.create; class ce extends ne { } class ue extends ne { _patch(e) { return this.businessProfile = e.businessProfile, super._patch(e) } } const le = class { static create(e, t) { return t.isBusiness ? new ue(e, t) : new ce(e, t) } }.create; class pe extends $ { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.pushname = e.pushname, this.wid = e.wid, this.me = e.wid, this.phone = e.phone, this.platform = e.platform, super._patch(e) } async getBatteryStatus() { return await this.client.pupPage.evaluate((() => { const { battery: e, plugged: t } = window.SWA_Store.Conn; return { battery: e, plugged: t } })) } } class he extends $ { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { return this.id = e.id, this.body = e.body || "", this.type = e.subtype, this.timestamp = e.t, this.chatId = "object" == typeof e.id.remote ? e.id.remote._serialized : e.id.remote, this.author = "object" == typeof e.author ? e.author._serialized : e.author, this.recipientIds = [], e.recipients && (this.recipientIds = e.recipients), super._patch(e) } getChat() { return this.client.getChatById(this.chatId) } getContact() { return this.client.getContactById(this.author) } async getRecipients() { return await Promise.all(this.recipientIds.map((async e => await this.client.getContactById(e)))) } async reply(e, t = {}) { return this.client.sendMessage(this.chatId, e, t) } } class we extends $ { constructor(e, t) { super(e), t && this._patch(t) } _patch(e) { this.id = e.id, this.name = e.name, this.hexColor = e.hexColor } async getChats() { return this.client.getChatsByLabelId(this.id) } } class me { constructor(e, t, i, n) { if (this.body = e, this.title = i, this.footer = n, e instanceof Q ? (this.type = "media", this.title = "") : this.type = "chat", this.buttons = this._format(t), !this.buttons.length) throw "[BT01] No buttons" } _format(e) { return (e = e.slice(0, 3)).map((e => ({ buttonId: e.id ? String(e.id) : d(6), buttonText: { displayText: e.body }, type: 1 }))) } } class fe { constructor(e, t, i, n, a) { this.description = e, this.buttonText = t, this.title = n, this.footer = a, this.sections = this._format(i) } _format(e) { if (!e.length) throw "[LT02] List without sections"; if (e.length > 1 && e.filter((e => void 0 === e.title)).length > 1) throw "[LT05] You can't have more than one empty title."; return e.map((e => { if (!e.rows.length) throw "[LT03] Section without rows"; return { title: e.title ? e.title : void 0, rows: e.rows.map((e => { if (!e.title) throw "[LT04] Row without title"; return { rowId: e.id ? e.id : d(6), title: e.title, description: e.description ? e.description : "" } })) } })) } } class ge { constructor(e, t, i = {}) { this.pollName = e.trim(), this.pollOptions = t.map(((e, t) => ({ name: e.trim(), localId: t }))), this.options = { allowMultipleAnswers: !0 === i.allowMultipleAnswers, messageSecret: i.messageSecret } } } (new class extends r { constructor(e = {}) { super(), this.options = function (e, t) { if (!t) return e; for (const a in e) i = t, n = a, Object.prototype.hasOwnProperty.call(i, n) && void 0 !== t[a] ? t[a] === Object(t[a]) && (t[a] = Util.mergeDefault(e[a], t[a])) : t[a] = e[a]; var i, n; return t }(l, e), this.pupPage = s.Page, this.currentIndexHtml = null, this.lastLoggedOut = !1 } async inject(e = !1) { await this.pupPage.waitForFunction((() => { var e; return null != (null == (e = window.Debug) ? void 0 : e.VERSION) }), { timeout: this.options.authTimeoutMs }), await this.pupPage.evaluate(V); const t = await this.pupPage.evaluate((async () => { let e = window.SWA_AuthStore.AppState.state; return "OPENING" !== e && "UNLAUNCHED" !== e && "PAIRING" !== e || await new Promise((e => { window.SWA_AuthStore.AppState.on("change:state", (function t(i, n) { "OPENING" !== n && "UNLAUNCHED" !== n && "PAIRING" !== n && (window.SWA_AuthStore.AppState.off("change:state", t), e()) })) })), e = window.SWA_AuthStore.AppState.state, "UNPAIRED" == e || "UNPAIRED_IDLE" == e })); console.log("is authentication needed", t), t && console.log("authentication needed"), e || (await this.pupPage.exposeFunction("onAuthAppStateChangedEvent", (async e => { })), await this.pupPage.exposeFunction("onAppStateHasSyncedEvent", (async () => { await this.pupPage.evaluate((async () => void 0 !== window.SWA_Store && void 0 !== window.WWebJS)) || (await new Promise((e => setTimeout(e, 1e3))), await this.pupPage.evaluate(K), await this.pupPage.waitForFunction((() => null != window.SWA_Store)), this.info = new pe(this, await this.pupPage.evaluate((() => ({ ...window.SWA_Store.Conn.serialize(), wid: window.SWA_Store.User.getMaybeMePnUser })))), this.interface = new u(this), await this.pupPage.evaluate(H), await this.attachEventListeners(e), e = !0), this.emit(p) })), await this.pupPage.exposeFunction("onOfflineProgressUpdateEvent", (async e => { this.emit(k, e, "WhatsApp") }))), await this.pupPage.evaluate((() => { window.SWA_AuthStore.AppState.on("change:state", ((e, t) => { window.onAuthAppStateChangedEvent(t) })), window.SWA_AuthStore.AppState.on("change:hasSynced", (() => { window.onAppStateHasSyncedEvent() })), window.SWA_AuthStore.Cmd.on("offline_progress_update", (() => { window.onOfflineProgressUpdateEvent(window.SWA_AuthStore.OfflineMessageHandler.getOfflineDeliveryProgress()) })) })) } async initialize() { await this.inject() } async requestPairingCode(e, t = !0) { return await this.pupPage.evaluate((async (e, t) => (window.SWA_AuthStore.PairingCodeLinkUtils.setPairingType("ALT_DEVICE_LINKING"), await window.SWA_AuthStore.PairingCodeLinkUtils.initializeAltDeviceLinking(), window.SWA_AuthStore.PairingCodeLinkUtils.startAltLinkingFlow(e, t))), e, t) } async attachEventListeners(e = !1) { if (!e) { let e; await this.pupPage.exposeFunction("onAddMessageEvent", (e => { if ("gp2" === e.type) { const t = new he(this, e); return void (["add", "invite", "linked_group_join"].includes(e.subtype) ? this.emit(M, t) : "remove" === e.subtype || "leave" === e.subtype ? this.emit(P, t) : "promote" === e.subtype || "demote" === e.subtype ? this.emit(E, t) : "created_membership_requests" === e.subtype ? this.emit(R, t) : this.emit(O, t)) } const t = new ae(this, e); this.emit(g, t), e.id.fromMe || this.emit(m, t) })), await this.pupPage.exposeFunction("onChangeMessageTypeEvent", (t => { if ("revoked" === t.type) { const i = new ae(this, t); let n; e && t.id.id === e.id.id && (n = new ae(this, e)), this.emit(S, i, n) } })), await this.pupPage.exposeFunction("onChangeMessageEvent", (t => { "revoked" !== t.type && (e = t); const i = "gp2" === t.type && "modify" === t.subtype, n = "notification_template" === t.type && "change_number" === t.subtype; if (i || n) { const e = new ae(this, t), a = i ? t.recipients[0] : t.to, o = i ? t.author : t.templateParams.find((e => e !== a)); this.emit(C, e, o, a, n) } })), await this.pupPage.exposeFunction("onRemoveMessageEvent", (e => { if (!e.isNewMsg) return; const t = new ae(this, e); this.emit(y, t) })), await this.pupPage.exposeFunction("onMessageAckEvent", ((e, t) => { const i = new ae(this, e); this.emit(b, i, t) })), await this.pupPage.exposeFunction("onChatUnreadCountEvent", (async e => { const t = await this.getChatById(e.id); this.emit(W, t) })), await this.pupPage.exposeFunction("onMessageMediaUploadedEvent", (e => { const t = new ae(this, e); this.emit(v, t) })), await this.pupPage.exposeFunction("onAppStateChangedEvent", (async e => { this.emit(L, e); const t = [J, j, z, G]; this.options.takeoverOnConflict && (t.push(D), e === D && setTimeout((() => { this.pupPage.evaluate((() => window.SWA_Store.AppState.takeover())) }), this.options.takeoverTimeoutMs)), t.includes(e) || (this.emit(T, e), this.destroy()) })), await this.pupPage.exposeFunction("onReaction", (e => { for (const t of e) this.emit(A, new ie(this, t)) })), await this.pupPage.exposeFunction("onRemoveChatEvent", (async e => { const t = await this.getChatById(e.id); this.emit(h, t) })), await this.pupPage.exposeFunction("onArchiveChatEvent", (async (e, t, i) => { const n = await this.getChatById(e.id); this.emit(w, n, t, i) })), await this.pupPage.exposeFunction("onEditMessageEvent", ((e, t, i) => { "revoked" !== e.type && this.emit(_, new ae(this, e), t, i) })), await this.pupPage.exposeFunction("onAddMessageCiphertextEvent", (e => { this.emit(f, new ae(this, e)) })) } await this.pupPage.evaluate((() => { window.SWA_Store.Msg.on("change:ack", ((e, t) => { window.onMessageAckEvent(window.WWebJS.getMessageModel(e), t) })) })) } async destroy() { } async logout() { await this.pupPage.evaluate((() => window.SWA_Store.AppState.logout())) } async getWWebVersion() { return await this.pupPage.evaluate((() => window.Debug.VERSION)) } async sendSeen(e) { return await this.pupPage.evaluate((async e => window.WWebJS.sendSeen(e)), e) } async sendMessage(e, t, i = {}) { i.mentions && (!Array.isArray(i.mentions) && (i.mentions = [i.mentions]), i.mentions.some((e => e instanceof ne)) && (console.warn("Mentions with an array of Contact are now deprecated. See more at https://github.com/pedroslopez/whatsapp-web.js/pull/2166."), i.mentions = i.mentions.map((e => e.id._serialized)))), i.groupMentions && !Array.isArray(i.groupMentions) && (i.groupMentions = [i.groupMentions]); let n = { linkPreview: !1 !== i.linkPreview || void 0, sendAudioAsVoice: i.sendAudioAsVoice, sendVideoAsGif: i.sendVideoAsGif, sendMediaAsSticker: i.sendMediaAsSticker, sendMediaAsDocument: i.sendMediaAsDocument, caption: i.caption, quotedMessageId: i.quotedMessageId, parseVCards: !1 !== i.parseVCards, mentionedJidList: i.mentions || [], groupMentions: i.groupMentions, extraOptions: i.extra }; const a = void 0 === i.sendSeen || i.sendSeen; t instanceof Q ? (n.attachment = t, n.isViewOnce = i.isViewOnce, t = "") : i.media instanceof Q ? (n.attachment = i.media, n.caption = t, n.isViewOnce = i.isViewOnce, t = "") : t instanceof X ? (n.location = t, t = "") : t instanceof ge ? (n.poll = t, t = "") : t instanceof ne ? (n.contactCard = t.id._serialized, t = "") : Array.isArray(t) && t.length > 0 && t[0] instanceof ne ? (n.contactCardList = t.map((e => e.id._serialized)), t = "") : t instanceof me ? ("chat" !== t.type && (n.attachment = t.body), n.buttons = t, t = "") : t instanceof fe && (n.list = t, t = ""), n.sendMediaAsSticker && n.attachment && (n.attachment = await formatToWebpSticker(n.attachment, { name: i.stickerName, author: i.stickerAuthor, categories: i.stickerCategories }, this.pupPage)); const o = await this.pupPage.evaluate((async (e, t, i, n) => { const a = window.SWA_Store.WidFactory.createWid(e), o = await window.SWA_Store.Chat.find(a); n && await window.WWebJS.sendSeen(e); const r = await window.WWebJS.sendMessage(o, t, i, n); return window.WWebJS.getMessageModel(r) }), e, t, n, a); return new ae(this, o) } async searchMessages(e, t = {}) { return (await this.pupPage.evaluate((async (e, t, i, n) => { const { messages: a } = await window.SWA_Store.Msg.search(e, t, i, n); return a.map((e => window.WWebJS.getMessageModel(e))) }), e, t.page, t.limit, t.chatId)).map((e => new ae(this, e))) } async getChats() { return (await this.pupPage.evaluate((async () => await window.WWebJS.getChats()))).map((e => de(this, e))) } async getChatById(e) { let t = await this.pupPage.evaluate((async e => await window.WWebJS.getChat(e)), e); return de(this, t) } async getContacts() { return (await this.pupPage.evaluate((() => window.WWebJS.getContacts()))).map((e => le(this, e))) } async getContactById(e) { let t = await this.pupPage.evaluate((e => window.WWebJS.getContact(e)), e); return le(this, t) } async getMessageById(e) { const t = await this.pupPage.evaluate((async e => { let t = window.SWA_Store.Msg.get(e); if (t) return window.WWebJS.getMessageModel(t); if (3 !== e.split("_").length) throw new Error("Invalid serialized message id specified"); let i = await window.SWA_Store.Msg.getMessagesById([e]); return i && i.messages.length && (t = i.messages[0]), t ? window.WWebJS.getMessageModel(t) : void 0 }), e); return t ? new ae(this, t) : null } async getInviteInfo(e) { return await this.pupPage.evaluate((e => window.SWA_Store.GroupInvite.queryGroupInvite(e)), e) } async acceptInvite(e) { return (await this.pupPage.evaluate((async e => await window.SWA_Store.GroupInvite.joinGroupViaInvite(e)), e)).gid._serialized } async getState() { return await this.pupPage.evaluate((() => window.SWA_Store ? window.SWA_Store.AppState.state : null)) } async archiveChat(e) { return await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Chat.get(e); return await window.SWA_Store.Cmd.archiveChat(t, !0), !0 }), e) } async unarchiveChat(e) { return await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Chat.get(e); return await window.SWA_Store.Cmd.archiveChat(t, !1), !1 }), e) } async pinChat(e) { return this.pupPage.evaluate((async e => { let t = window.SWA_Store.Chat.get(e); if (t.pin) return !0; const i = window.SWA_Store.Chat.getModelsArray(); if (i.length > 3) { if (i[2].pin) return !1 } return await window.SWA_Store.Cmd.pinChat(t, !0), !0 }), e) } async unpinChat(e) { return this.pupPage.evaluate((async e => { let t = window.SWA_Store.Chat.get(e); return !!t.pin && (await window.SWA_Store.Cmd.pinChat(t, !1), !1) }), e) } async muteChat(e, t) { t = t ? t.getTime() / 1e3 : -1, await this.pupPage.evaluate((async (e, t) => { let i = await window.SWA_Store.Chat.get(e); await i.mute.mute({ expiration: t, sendDevice: !0 }) }), e, t || -1) } async unmuteChat(e) { await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Chat.get(e); await window.SWA_Store.Cmd.muteChat(t, !1) }), e) } async markChatUnread(e) { await this.pupPage.evaluate((async e => { let t = await window.SWA_Store.Chat.get(e); await window.SWA_Store.Cmd.markChatUnread(t, !0) }), e) } async getCommonGroups(e) { const t = await this.pupPage.evaluate((async e => { let t = window.SWA_Store.Contact.get(e); if (!t) { const i = window.SWA_Store.WidFactory.createUserWid(e); t = new (0, window.SWA_Store.Contact.getModelsArray().find((e => !e.isGroup)).constructor)({ id: i }) } if (t.commonGroups) return t.commonGroups.serialize(); return await window.SWA_Store.findCommonGroups(t) ? t.commonGroups.serialize() : [] }), e), i = []; for (const n of t) i.push(n.id); return i } async resetState() { await this.pupPage.evaluate((() => { window.SWA_Store.AppState.phoneWatchdog.shiftTimer.forceRunNow() })) } async isRegisteredUser(e) { return Boolean(await this.getNumberId(e)) } async getNumberId(e, t) { var i; e = String(e).replace("@c.us", ""); const n = (() => { var e; try { return !!(null == (e = window.require("WAComms")) ? void 0 : e.getComms()) } catch (t) { return !0 } })(); try { n || await (null == (i = require("WAWebStartBackend")) ? void 0 : i.startBackend()) } catch (a) { } return await this.pupPage.evaluate((async e => { let i = c(e, t); e = i.number, (t = i.countryCode) || (t = window.SWA_Store.PhoneFindCC.findCC(e), e = e.substring(t.length)); let n = await window.SWA_Store.PhoneNumberFormatUtils.isPhoneNumberValid(Number(t), e); if (n || (i = c(e, t), e = i.number, t = i.countryCode), 975 != Number(t) && (Fe("Checking for valid number", t, e), n = await window.SWA_Store.PhoneNumberFormatUtils.isPhoneNumberValid(Number(t), e), !n)) return null; const a = await window.SWA_Store.QueryExistJob.queryPhoneExists(`+${i.fullNumber}`); return a && void 0 !== a.wid ? a.wid : null }), e) } async getFormattedNumber(e) { return e.endsWith("@s.whatsapp.net") || (e = e.replace("c.us", "s.whatsapp.net")), e.includes("@s.whatsapp.net") || (e = `${e}@s.whatsapp.net`), await this.pupPage.evaluate((async e => window.SWA_Store.NumberInfo.formattedPhoneNumber(e)), e) } async getCountryCode(e) { return e = e.replace(" ", "").replace("+", "").replace("@c.us", ""), await this.pupPage.evaluate((async e => window.SWA_Store.NumberInfo.findCC ? window.SWA_Store.NumberInfo.findCC(e) : window.SWA_Store.PhoneFindCC.findCC(e)), e) } async getLabels() { return (await this.pupPage.evaluate((async () => window.WWebJS.getLabels()))).map((e => new we(this, e))) } async getLabelById(e) { const t = await this.pupPage.evaluate((async e => window.WWebJS.getLabel(e)), e); return new we(this, t) } async getChatLabels(e) { return (await this.pupPage.evaluate((async e => window.WWebJS.getChatLabels(e)), e)).map((e => new we(this, e))) } async getChatsByLabelId(e) { const t = await this.pupPage.evaluate((async e => window.SWA_Store.Label.get(e).labelItemCollection.getModelsArray().reduce(((e, t) => ("Chat" === t.parentType && e.push(t.parentId), e)), [])), e); return Promise.all(t.map((e => this.getChatById(e)))) } async getBlockedContacts() { return (await this.pupPage.evaluate((() => { let e = window.SWA_Store.Blocklist.getModelsArray().map((e => e.id._serialized)); return Promise.all(e.map((e => window.WWebJS.getContact(e)))) }))).map((e => le(this.client, e))) } async setProfilePicture(e) { return await this.pupPage.evaluate(((e, t) => window.WWebJS.setPicture(e, t)), this.info.wid._serialized, e) } async deleteProfilePicture() { return await this.pupPage.evaluate((e => window.WWebJS.deletePicture(e)), this.info.wid._serialized) } async addOrRemoveLabels(e, t) { return this.pupPage.evaluate((async (e, t) => { if (-1 === ["smba", "smbi"].indexOf(window.SWA_Store.Conn.platform)) throw "[LT01] Only Whatsapp business"; const i = window.WWebJS.getLabels().filter((t => void 0 !== e.find((e => e == t.id)))), n = window.SWA_Store.Chat.filter((e => t.includes(e.id._serialized))); let a = i.map((e => ({ id: e.id, type: "add" }))); return n.forEach((e => { (e.labels || []).forEach((e => { a.find((t => t.id == e)) || a.push({ id: e, type: "remove" }) })) })), await window.SWA_Store.Label.addOrRemoveLabels(a, n) }), e, t) } async getGroupMembershipRequests(e) { return await this.pupPage.evaluate((async e => { const t = window.SWA_Store.WidFactory.createWid(e); return await window.SWA_Store.MembershipRequestUtils.getMembershipApprovalRequests(t) }), e) } }).on("message_ack", (e => { Fe("Got acknolegement", e.ack, e); const t = new CustomEvent("msg_ack", { detail: { id: e.id.id, msg: e.body, ack: e.ack } }); document.body.dispatchEvent(t) })); const Se = { number: "", CCode: "", phoneNumber: "", userName: "" }; const ye = class e { static async storage(t) { if (t.set) return void (await _e({ requestKey: "fetchData-" + __privateWrapper(e, i)._++, data: { action: "storage", set: t.set } })); return await _e({ requestKey: "fetchData-" + __privateWrapper(e, i)._++, data: { action: "storage", get: t.get } }) } }; i = new WeakMap, __privateAdd(ye, i, 1), __publicField(ye, "get", (async (e, t) => { const n = await _e({ requestKey: "fetchData-" + __privateWrapper(ye, i)._++, data: { action: "fetchData", data: { url: e, method: "GET", token: null == t ? void 0 : t.token, retryLimit: null == t ? void 0 : t.retryLimit } } }), a = "FetchDataTimeout" == (null == n ? void 0 : n.name), o = "AxiosError" == (null == n ? void 0 : n.name); if (a || o) throw n; return n })), __publicField(ye, "post", (async (e, t, n) => { console.log("post", e, t, n); const a = Se, o = (null == n ? void 0 : n.addNumber) && a ? { phoneNumber: a.phoneNumber, CCode: a.CCode, ...t } : t, r = await _e({ requestKey: "fetchData-" + __privateWrapper(ye, i)._++, data: { action: "fetchData", data: { url: e, method: "POST", body: o, token: null == n ? void 0 : n.token, retryLimit: null == n ? void 0 : n.retryLimit } } }), s = "FetchDataTimeout" == (null == r ? void 0 : r.name), d = "AxiosError" == (null == r ? void 0 : r.name); if (s || d) throw r; return r })), __publicField(ye, "upload_contact_list", (async e => { console.log("upload_contact_list", e); const t = await _e({ requestKey: "fetchData-" + __privateWrapper(ye, i)._++, data: { action: "upload_contact_list", data: { body: e } } }), n = "FetchDataTimeout" == (null == t ? void 0 : t.name), a = "AxiosError" == (null == t ? void 0 : t.name); if (n || a) throw t; return t })), __publicField(ye, "put", (async (e, t, n) => { const a = await _e({ requestKey: "fetchData-" + __privateWrapper(ye, i)._++, data: { action: "fetchData", data: { url: e, method: "PUT", body: t, token: null == n ? void 0 : n.token, retryLimit: null == n ? void 0 : n.retryLimit } } }), o = "FetchDataTimeout" == (null == a ? void 0 : a.name), r = "AxiosError" == (null == a ? void 0 : a.name); if (o || r) throw a; return a })), __publicField(ye, "delete", (async (e, t, n) => { const a = await _e({ requestKey: "fetchData-" + __privateWrapper(ye, i)._++, data: { action: "fetchData", data: { url: e, method: "DELETE", body: t, token: null == n ? void 0 : n.token, retryLimit: null == n ? void 0 : n.retryLimit } } }), o = "FetchDataTimeout" == (null == a ? void 0 : a.name), r = "AxiosError" == (null == a ? void 0 : a.name); if (o || r) throw a; return a })), __publicField(ye, "logout", (async () => await _e({ requestKey: "fetchData-" + __privateWrapper(ye, i)._++, data: { action: "logout" } }))), __publicField(ye, "screenLock", (async e => await _e({ requestKey: "fetchData-" + __privateWrapper(ye, i)._++, data: { action: "screenLock", data: { freeScreen: !!(null == e ? void 0 : e.freeScreen) } } }))); let be = ye; function _e(e) { return new Promise(((t, i) => { const n = setTimeout((() => { document.body.removeEventListener("connect_sheet_wa_receive", a), i({ name: "FetchDataTimeout", message: "Request timed out", requests: e }) }), 3e4), a = i => { const o = i.detail; o.requestKey === e.requestKey && (t(o.response), document.body.removeEventListener("connect_sheet_wa_receive", a), clearTimeout(n)) }; document.body.addEventListener("connect_sheet_wa_receive", a); const o = new CustomEvent("connect_sheet_wa_sent", { detail: { data: JSON.stringify(e.data), requestKey: e.requestKey } }); document.body.dispatchEvent(o) })) } const We = class e { constructor() { __publicField(this, "_debugMode", !1) } static getInstance() { return e.instance || (e.instance = new e), e.instance } get debugMode() { return this._debugMode } set debugMode(e) { this._debugMode = e } }; __publicField(We, "instance"); let Ae = We; const ve = e => chrome.tabs.create({ url: e }), Ce = e => chrome.tabs.remove(e), Me = e => chrome.tabs.query({ url: e }), Pe = e => chrome.tabs.update(e, { active: !0 }), Ee = e => chrome.tabs.reload(e), Re = async function (e) { return await chrome.storage.local.get(e) }, Oe = function (e) { return chrome.storage.local.set(e) }, ke = function (e) { return chrome.storage.local.remove(e) }; function Te(e, t) { return chrome.tabs.sendMessage(e, t) } function Le(e) { return new Promise((t => setTimeout(t, e))) } let xe = []; const Ie = 5; function Fe(...e) { const t = Ae.getInstance(); if (self.showLogs && console.log(...e), t.debugMode && (xe.push(e), xe.length >= Ie)) try { be.post(`${o}/save-error-logs`, { token: !0, data: { message: xe } }), xe = [] } catch (i) { console.log("error in log", i) } } function Ne() { return new Promise((e => { const t = i => { a("WA_content_script_loaded")(i) && (e(), chrome.runtime.onMessage.removeListener(t)) }; chrome.runtime.onMessage.addListener(t) })) } async function Ue(e) { const t = await Me(`${n}/*`); let i, a = !1; const o = t.map((async (n, o) => { const r = t.length - 1 == o; if (a || !e.makeLastTabActive || !r) return n.id == e.activeWATabID ? (i = n.id, void (a = !0)) : void (await Ce(n.id)); i = n.id })); return await Promise.all(o), i } function Be() { chrome.runtime.onInstalled.addListener((async function (e) { Fe("Extension onInstalled trigured details are", e), "install" == e.reason && (chrome.tabs.create({ url: "https://sheetwa.com/getting-started-with-sheetwa?ext=true" }), await (async () => { await Oe({ hideName: !0, hideMsg: !0, hideImages: !0, hideChats: !0, toggle: !1, hoverUnblur: !0, hideMsgBox: !0, hideQuickReplies: !0 }) })()); const t = chrome.runtime.getManifest().version; await Re(["lastVersion"]), await Oe({ lastVersion: t }) })), chrome.runtime.setUninstallURL("https://sheetwa.com/uninstall-extension/?ext=true") } function qe(e, t) { return function () { return e.apply(t, arguments) } } const { toString: De } = Object.prototype, { getPrototypeOf: Je } = Object, je = (e => t => { const i = De.call(t); return e[i] || (e[i] = i.slice(8, -1).toLowerCase()) })(Object.create(null)), ze = e => (e = e.toLowerCase(), t => je(t) === e), Ge = e => t => typeof t === e, { isArray: Ve } = Array, Ke = Ge("undefined"); const He = ze("ArrayBuffer"); const $e = Ge("string"), Qe = Ge("function"), Xe = Ge("number"), Ye = e => null !== e && "object" == typeof e, Ze = e => { if ("object" !== je(e)) return !1; const t = Je(e); return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || Symbol.toStringTag in e || Symbol.iterator in e) }, et = ze("Date"), tt = ze("File"), it = ze("Blob"), nt = ze("FileList"), at = ze("URLSearchParams"), [ot, rt, st, dt] = ["ReadableStream", "Request", "Response", "Headers"].map(ze); function ct(e, t, { allOwnKeys: i = !1 } = {}) { if (null == e) return; let n, a; if ("object" != typeof e && (e = [e]), Ve(e)) for (n = 0, a = e.length; n < a; n++)t.call(null, e[n], n, e); else { const a = i ? Object.getOwnPropertyNames(e) : Object.keys(e), o = a.length; let r; for (n = 0; n < o; n++)r = a[n], t.call(null, e[r], r, e) } } function ut(e, t) { t = t.toLowerCase(); const i = Object.keys(e); let n, a = i.length; for (; a-- > 0;)if (n = i[a], t === n.toLowerCase()) return n; return null } const lt = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, pt = e => !Ke(e) && e !== lt; const ht = (e => t => e && t instanceof e)("undefined" != typeof Uint8Array && Je(Uint8Array)), wt = ze("HTMLFormElement"), mt = (({ hasOwnProperty: e }) => (t, i) => e.call(t, i))(Object.prototype), ft = ze("RegExp"), gt = (e, t) => { const i = Object.getOwnPropertyDescriptors(e), n = {}; ct(i, ((i, a) => { let o; !1 !== (o = t(i, a, e)) && (n[a] = o || i) })), Object.defineProperties(e, n) }, St = "abcdefghijklmnopqrstuvwxyz", yt = "0123456789", bt = { DIGIT: yt, ALPHA: St, ALPHA_DIGIT: St + St.toUpperCase() + yt }; const _t = ze("AsyncFunction"), Wt = (At = "function" == typeof setImmediate, vt = Qe(lt.postMessage), At ? setImmediate : vt ? (Ct = `axios@${Math.random()}`, Mt = [], lt.addEventListener("message", (({ source: e, data: t }) => { e === lt && t === Ct && Mt.length && Mt.shift()() }), !1), e => { Mt.push(e), lt.postMessage(Ct, "*") }) : e => setTimeout(e)); var At, vt, Ct, Mt; const Pt = "undefined" != typeof queueMicrotask ? queueMicrotask.bind(lt) : "undefined" != typeof process && process.nextTick || Wt, Et = { isArray: Ve, isArrayBuffer: He, isBuffer: function (e) { return null !== e && !Ke(e) && null !== e.constructor && !Ke(e.constructor) && Qe(e.constructor.isBuffer) && e.constructor.isBuffer(e) }, isFormData: e => { let t; return e && ("function" == typeof FormData && e instanceof FormData || Qe(e.append) && ("formdata" === (t = je(e)) || "object" === t && Qe(e.toString) && "[object FormData]" === e.toString())) }, isArrayBufferView: function (e) { let t; return t = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && He(e.buffer), t }, isString: $e, isNumber: Xe, isBoolean: e => !0 === e || !1 === e, isObject: Ye, isPlainObject: Ze, isReadableStream: ot, isRequest: rt, isResponse: st, isHeaders: dt, isUndefined: Ke, isDate: et, isFile: tt, isBlob: it, isRegExp: ft, isFunction: Qe, isStream: e => Ye(e) && Qe(e.pipe), isURLSearchParams: at, isTypedArray: ht, isFileList: nt, forEach: ct, merge: function e() { const { caseless: t } = pt(this) && this || {}, i = {}, n = (n, a) => { const o = t && ut(i, a) || a; Ze(i[o]) && Ze(n) ? i[o] = e(i[o], n) : Ze(n) ? i[o] = e({}, n) : Ve(n) ? i[o] = n.slice() : i[o] = n }; for (let a = 0, o = arguments.length; a < o; a++)arguments[a] && ct(arguments[a], n); return i }, extend: (e, t, i, { allOwnKeys: n } = {}) => (ct(t, ((t, n) => { i && Qe(t) ? e[n] = qe(t, i) : e[n] = t }), { allOwnKeys: n }), e), trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e), inherits: (e, t, i, n) => { e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), i && Object.assign(e.prototype, i) }, toFlatObject: (e, t, i, n) => { let a, o, r; const s = {}; if (t = t || {}, null == e) return t; do { for (a = Object.getOwnPropertyNames(e), o = a.length; o-- > 0;)r = a[o], n && !n(r, e, t) || s[r] || (t[r] = e[r], s[r] = !0); e = !1 !== i && Je(e) } while (e && (!i || i(e, t)) && e !== Object.prototype); return t }, kindOf: je, kindOfTest: ze, endsWith: (e, t, i) => { e = String(e), (void 0 === i || i > e.length) && (i = e.length), i -= t.length; const n = e.indexOf(t, i); return -1 !== n && n === i }, toArray: e => { if (!e) return null; if (Ve(e)) return e; let t = e.length; if (!Xe(t)) return null; const i = new Array(t); for (; t-- > 0;)i[t] = e[t]; return i }, forEachEntry: (e, t) => { const i = (e && e[Symbol.iterator]).call(e); let n; for (; (n = i.next()) && !n.done;) { const i = n.value; t.call(e, i[0], i[1]) } }, matchAll: (e, t) => { let i; const n = []; for (; null !== (i = e.exec(t));)n.push(i); return n }, isHTMLForm: wt, hasOwnProperty: mt, hasOwnProp: mt, reduceDescriptors: gt, freezeMethods: e => { gt(e, ((t, i) => { if (Qe(e) && -1 !== ["arguments", "caller", "callee"].indexOf(i)) return !1; const n = e[i]; Qe(n) && (t.enumerable = !1, "writable" in t ? t.writable = !1 : t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + i + "'") })) })) }, toObjectSet: (e, t) => { const i = {}, n = e => { e.forEach((e => { i[e] = !0 })) }; return Ve(e) ? n(e) : n(String(e).split(t)), i }, toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function (e, t, i) { return t.toUpperCase() + i })), noop: () => { }, toFiniteNumber: (e, t) => null != e && Number.isFinite(e = +e) ? e : t, findKey: ut, global: lt, isContextDefined: pt, ALPHABET: bt, generateString: (e = 16, t = bt.ALPHA_DIGIT) => { let i = ""; const { length: n } = t; for (; e--;)i += t[Math.random() * n | 0]; return i }, isSpecCompliantForm: function (e) { return !!(e && Qe(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator]) }, toJSONObject: e => { const t = new Array(10), i = (e, n) => { if (Ye(e)) { if (t.indexOf(e) >= 0) return; if (!("toJSON" in e)) { t[n] = e; const a = Ve(e) ? [] : {}; return ct(e, ((e, t) => { const o = i(e, n + 1); !Ke(o) && (a[t] = o) })), t[n] = void 0, a } } return e }; return i(e, 0) }, isAsyncFn: _t, isThenable: e => e && (Ye(e) || Qe(e)) && Qe(e.then) && Qe(e.catch), setImmediate: Wt, asap: Pt }; function Rt(e, t, i, n, a) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.message = e, this.name = "AxiosError", t && (this.code = t), i && (this.config = i), n && (this.request = n), a && (this.response = a, this.status = a.status ? a.status : null) } Et.inherits(Rt, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: Et.toJSONObject(this.config), code: this.code, status: this.status } } }); const Ot = Rt.prototype, kt = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e => { kt[e] = { value: e } })), Object.defineProperties(Rt, kt), Object.defineProperty(Ot, "isAxiosError", { value: !0 }), Rt.from = (e, t, i, n, a, o) => { const r = Object.create(Ot); return Et.toFlatObject(e, r, (function (e) { return e !== Error.prototype }), (e => "isAxiosError" !== e)), Rt.call(r, e.message, t, i, n, a), r.cause = e, r.name = e.name, o && Object.assign(r, o), r }; function Tt(e) { return Et.isPlainObject(e) || Et.isArray(e) } function Lt(e) { return Et.endsWith(e, "[]") ? e.slice(0, -2) : e } function xt(e, t, i) { return e ? e.concat(t).map((function (e, t) { return e = Lt(e), !i && t ? "[" + e + "]" : e })).join(i ? "." : "") : t } const It = Et.toFlatObject(Et, {}, null, (function (e) { return /^is[A-Z]/.test(e) })); function Ft(e, t, i) { if (!Et.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData; const n = (i = Et.toFlatObject(i, { metaTokens: !0, dots: !1, indexes: !1 }, !1, (function (e, t) { return !Et.isUndefined(t[e]) }))).metaTokens, a = i.visitor || c, o = i.dots, r = i.indexes, s = (i.Blob || "undefined" != typeof Blob && Blob) && Et.isSpecCompliantForm(t); if (!Et.isFunction(a)) throw new TypeError("visitor must be a function"); function d(e) { if (null === e) return ""; if (Et.isDate(e)) return e.toISOString(); if (!s && Et.isBlob(e)) throw new Rt("Blob is not supported. Use a Buffer instead."); return Et.isArrayBuffer(e) || Et.isTypedArray(e) ? s && "function" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e } function c(e, i, a) { let s = e; if (e && !a && "object" == typeof e) if (Et.endsWith(i, "{}")) i = n ? i : i.slice(0, -2), e = JSON.stringify(e); else if (Et.isArray(e) && function (e) { return Et.isArray(e) && !e.some(Tt) }(e) || (Et.isFileList(e) || Et.endsWith(i, "[]")) && (s = Et.toArray(e))) return i = Lt(i), s.forEach((function (e, n) { !Et.isUndefined(e) && null !== e && t.append(!0 === r ? xt([i], n, o) : null === r ? i : i + "[]", d(e)) })), !1; return !!Tt(e) || (t.append(xt(a, i, o), d(e)), !1) } const u = [], l = Object.assign(It, { defaultVisitor: c, convertValue: d, isVisitable: Tt }); if (!Et.isObject(e)) throw new TypeError("data must be an object"); return function e(i, n) { if (!Et.isUndefined(i)) { if (-1 !== u.indexOf(i)) throw Error("Circular reference detected in " + n.join(".")); u.push(i), Et.forEach(i, (function (i, o) { !0 === (!(Et.isUndefined(i) || null === i) && a.call(t, i, Et.isString(o) ? o.trim() : o, n, l)) && e(i, n ? n.concat(o) : [o]) })), u.pop() } }(e), t } function Nt(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, (function (e) { return t[e] })) } function Ut(e, t) { this._pairs = [], e && Ft(e, this, t) } const Bt = Ut.prototype; function qt(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function Dt(e, t, i) { if (!t) return e; const n = i && i.encode || qt; Et.isFunction(i) && (i = { serialize: i }); const a = i && i.serialize; let o; if (o = a ? a(t, i) : Et.isURLSearchParams(t) ? t.toString() : new Ut(t, i).toString(n), o) { const t = e.indexOf("#"); -1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf("?") ? "?" : "&") + o } return e } Bt.append = function (e, t) { this._pairs.push([e, t]) }, Bt.toString = function (e) { const t = e ? function (t) { return e.call(this, t, Nt) } : Nt; return this._pairs.map((function (e) { return t(e[0]) + "=" + t(e[1]) }), "").join("&") }; class Jt { constructor() { this.handlers = [] } use(e, t, i) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: !!i && i.synchronous, runWhen: i ? i.runWhen : null }), this.handlers.length - 1 } eject(e) { this.handlers[e] && (this.handlers[e] = null) } clear() { this.handlers && (this.handlers = []) } forEach(e) { Et.forEach(this.handlers, (function (t) { null !== t && e(t) })) } } const jt = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, zt = { isBrowser: !0, classes: { URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : Ut, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] }, Gt = "undefined" != typeof window && "undefined" != typeof document, Vt = "object" == typeof navigator && navigator || void 0, Kt = Gt && (!Vt || ["ReactNative", "NativeScript", "NS"].indexOf(Vt.product) < 0), Ht = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts, $t = Gt && window.location.href || "http://localhost", Qt = { ...Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: Gt, hasStandardBrowserEnv: Kt, hasStandardBrowserWebWorkerEnv: Ht, navigator: Vt, origin: $t }, Symbol.toStringTag, { value: "Module" })), ...zt }; function Xt(e) { function t(e, i, n, a) { let o = e[a++]; if ("__proto__" === o) return !0; const r = Number.isFinite(+o), s = a >= e.length; if (o = !o && Et.isArray(n) ? n.length : o, s) return Et.hasOwnProp(n, o) ? n[o] = [n[o], i] : n[o] = i, !r; n[o] && Et.isObject(n[o]) || (n[o] = []); return t(e, i, n[o], a) && Et.isArray(n[o]) && (n[o] = function (e) { const t = {}, i = Object.keys(e); let n; const a = i.length; let o; for (n = 0; n < a; n++)o = i[n], t[o] = e[o]; return t }(n[o])), !r } if (Et.isFormData(e) && Et.isFunction(e.entries)) { const i = {}; return Et.forEachEntry(e, ((e, n) => { t(function (e) { return Et.matchAll(/\w+|\[(\w*)]/g, e).map((e => "[]" === e[0] ? "" : e[1] || e[0])) }(e), n, i, 0) })), i } return null } const Yt = { transitional: jt, adapter: ["xhr", "http", "fetch"], transformRequest: [function (e, t) { const i = t.getContentType() || "", n = i.indexOf("application/json") > -1, a = Et.isObject(e); a && Et.isHTMLForm(e) && (e = new FormData(e)); if (Et.isFormData(e)) return n ? JSON.stringify(Xt(e)) : e; if (Et.isArrayBuffer(e) || Et.isBuffer(e) || Et.isStream(e) || Et.isFile(e) || Et.isBlob(e) || Et.isReadableStream(e)) return e; if (Et.isArrayBufferView(e)) return e.buffer; if (Et.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString(); let o; if (a) { if (i.indexOf("application/x-www-form-urlencoded") > -1) return function (e, t) { return Ft(e, new Qt.classes.URLSearchParams, Object.assign({ visitor: function (e, t, i, n) { return Qt.isNode && Et.isBuffer(e) ? (this.append(t, e.toString("base64")), !1) : n.defaultVisitor.apply(this, arguments) } }, t)) }(e, this.formSerializer).toString(); if ((o = Et.isFileList(e)) || i.indexOf("multipart/form-data") > -1) { const t = this.env && this.env.FormData; return Ft(o ? { "files[]": e } : e, t && new t, this.formSerializer) } } return a || n ? (t.setContentType("application/json", !1), function (e, t, i) { if (Et.isString(e)) try { return (t || JSON.parse)(e), Et.trim(e) } catch (n) { if ("SyntaxError" !== n.name) throw n } return (i || JSON.stringify)(e) }(e)) : e }], transformResponse: [function (e) { const t = this.transitional || Yt.transitional, i = t && t.forcedJSONParsing, n = "json" === this.responseType; if (Et.isResponse(e) || Et.isReadableStream(e)) return e; if (e && Et.isString(e) && (i && !this.responseType || n)) { const i = !(t && t.silentJSONParsing) && n; try { return JSON.parse(e) } catch (a) { if (i) { if ("SyntaxError" === a.name) throw Rt.from(a, Rt.ERR_BAD_RESPONSE, this, null, this.response); throw a } } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: Qt.classes.FormData, Blob: Qt.classes.Blob }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; Et.forEach(["delete", "get", "head", "post", "put", "patch"], (e => { Yt.headers[e] = {} })); const Zt = Et.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), ei = Symbol("internals"); function ti(e) { return e && String(e).trim().toLowerCase() } function ii(e) { return !1 === e || null == e ? e : Et.isArray(e) ? e.map(ii) : String(e) } function ni(e, t, i, n, a) { return Et.isFunction(n) ? n.call(this, t, i) : (a && (t = i), Et.isString(t) ? Et.isString(n) ? -1 !== t.indexOf(n) : Et.isRegExp(n) ? n.test(t) : void 0 : void 0) } class ai { constructor(e) { e && this.set(e) } set(e, t, i) { const n = this; function a(e, t, i) { const a = ti(t); if (!a) throw new Error("header name must be a non-empty string"); const o = Et.findKey(n, a); (!o || void 0 === n[o] || !0 === i || void 0 === i && !1 !== n[o]) && (n[o || t] = ii(e)) } const o = (e, t) => Et.forEach(e, ((e, i) => a(e, i, t))); if (Et.isPlainObject(e) || e instanceof this.constructor) o(e, t); else if (Et.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim())) o((e => { const t = {}; let i, n, a; return e && e.split("\n").forEach((function (e) { a = e.indexOf(":"), i = e.substring(0, a).trim().toLowerCase(), n = e.substring(a + 1).trim(), !i || t[i] && Zt[i] || ("set-cookie" === i ? t[i] ? t[i].push(n) : t[i] = [n] : t[i] = t[i] ? t[i] + ", " + n : n) })), t })(e), t); else if (Et.isHeaders(e)) for (const [r, s] of e.entries()) a(s, r, i); else null != e && a(t, e, i); return this } get(e, t) { if (e = ti(e)) { const i = Et.findKey(this, e); if (i) { const e = this[i]; if (!t) return e; if (!0 === t) return function (e) { const t = Object.create(null), i = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let n; for (; n = i.exec(e);)t[n[1]] = n[2]; return t }(e); if (Et.isFunction(t)) return t.call(this, e, i); if (Et.isRegExp(t)) return t.exec(e); throw new TypeError("parser must be boolean|regexp|function") } } } has(e, t) { if (e = ti(e)) { const i = Et.findKey(this, e); return !(!i || void 0 === this[i] || t && !ni(0, this[i], i, t)) } return !1 } delete(e, t) { const i = this; let n = !1; function a(e) { if (e = ti(e)) { const a = Et.findKey(i, e); !a || t && !ni(0, i[a], a, t) || (delete i[a], n = !0) } } return Et.isArray(e) ? e.forEach(a) : a(e), n } clear(e) { const t = Object.keys(this); let i = t.length, n = !1; for (; i--;) { const a = t[i]; e && !ni(0, this[a], a, e, !0) || (delete this[a], n = !0) } return n } normalize(e) { const t = this, i = {}; return Et.forEach(this, ((n, a) => { const o = Et.findKey(i, a); if (o) return t[o] = ii(n), void delete t[a]; const r = e ? function (e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((e, t, i) => t.toUpperCase() + i)) }(a) : String(a).trim(); r !== a && delete t[a], t[r] = ii(n), i[r] = !0 })), this } concat(...e) { return this.constructor.concat(this, ...e) } toJSON(e) { const t = Object.create(null); return Et.forEach(this, ((i, n) => { null != i && !1 !== i && (t[n] = e && Et.isArray(i) ? i.join(", ") : i) })), t } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() { return Object.entries(this.toJSON()).map((([e, t]) => e + ": " + t)).join("\n") } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(e) { return e instanceof this ? e : new this(e) } static concat(e, ...t) { const i = new this(e); return t.forEach((e => i.set(e))), i } static accessor(e) { const t = (this[ei] = this[ei] = { accessors: {} }).accessors, i = this.prototype; function n(e) { const n = ti(e); t[n] || (!function (e, t) { const i = Et.toCamelCase(" " + t);["get", "set", "has"].forEach((n => { Object.defineProperty(e, n + i, { value: function (e, i, a) { return this[n].call(this, t, e, i, a) }, configurable: !0 }) })) }(i, e), t[n] = !0) } return Et.isArray(e) ? e.forEach(n) : n(e), this } } function oi(e, t) { const i = this || Yt, n = t || i, a = ai.from(n.headers); let o = n.data; return Et.forEach(e, (function (e) { o = e.call(i, o, a.normalize(), t ? t.status : void 0) })), a.normalize(), o } function ri(e) { return !(!e || !e.__CANCEL__) } function si(e, t, i) { Rt.call(this, null == e ? "canceled" : e, Rt.ERR_CANCELED, t, i), this.name = "CanceledError" } function di(e, t, i) { const n = i.config.validateStatus; i.status && n && !n(i.status) ? t(new Rt("Request failed with status code " + i.status, [Rt.ERR_BAD_REQUEST, Rt.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4], i.config, i.request, i)) : e(i) } ai.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), Et.reduceDescriptors(ai.prototype, (({ value: e }, t) => { let i = t[0].toUpperCase() + t.slice(1); return { get: () => e, set(e) { this[i] = e } } })), Et.freezeMethods(ai), Et.inherits(si, Rt, { __CANCEL__: !0 }); const ci = (e, t, i = 3) => { let n = 0; const a = function (e, t) { e = e || 10; const i = new Array(e), n = new Array(e); let a, o = 0, r = 0; return t = void 0 !== t ? t : 1e3, function (s) { const d = Date.now(), c = n[r]; a || (a = d), i[o] = s, n[o] = d; let u = r, l = 0; for (; u !== o;)l += i[u++], u %= e; if (o = (o + 1) % e, o === r && (r = (r + 1) % e), d - a < t) return; const p = c && d - c; return p ? Math.round(1e3 * l / p) : void 0 } }(50, 250); return function (e, t) { let i, n, a = 0, o = 1e3 / t; const r = (t, o = Date.now()) => { a = o, i = null, n && (clearTimeout(n), n = null), e.apply(null, t) }; return [(...e) => { const t = Date.now(), s = t - a; s >= o ? r(e, t) : (i = e, n || (n = setTimeout((() => { n = null, r(i) }), o - s))) }, () => i && r(i)] }((i => { const o = i.loaded, r = i.lengthComputable ? i.total : void 0, s = o - n, d = a(s); n = o; e({ loaded: o, total: r, progress: r ? o / r : void 0, bytes: s, rate: d || void 0, estimated: d && r && o <= r ? (r - o) / d : void 0, event: i, lengthComputable: null != r, [t ? "download" : "upload"]: !0 }) }), i) }, ui = (e, t) => { const i = null != e; return [n => t[0]({ lengthComputable: i, total: e, loaded: n }), t[1]] }, li = e => (...t) => Et.asap((() => e(...t))), pi = Qt.hasStandardBrowserEnv ? ((e, t) => i => (i = new URL(i, Qt.origin), e.protocol === i.protocol && e.host === i.host && (t || e.port === i.port)))(new URL(Qt.origin), Qt.navigator && /(msie|trident)/i.test(Qt.navigator.userAgent)) : () => !0, hi = Qt.hasStandardBrowserEnv ? { write(e, t, i, n, a, o) { const r = [e + "=" + encodeURIComponent(t)]; Et.isNumber(i) && r.push("expires=" + new Date(i).toGMTString()), Et.isString(n) && r.push("path=" + n), Et.isString(a) && r.push("domain=" + a), !0 === o && r.push("secure"), document.cookie = r.join("; ") }, read(e) { const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")); return t ? decodeURIComponent(t[3]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5) } } : { write() { }, read: () => null, remove() { } }; function wi(e, t) { return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) ? function (e, t) { return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e }(e, t) : t } const mi = e => e instanceof ai ? { ...e } : e; function fi(e, t) { t = t || {}; const i = {}; function n(e, t, i, n) { return Et.isPlainObject(e) && Et.isPlainObject(t) ? Et.merge.call({ caseless: n }, e, t) : Et.isPlainObject(t) ? Et.merge({}, t) : Et.isArray(t) ? t.slice() : t } function a(e, t, i, a) { return Et.isUndefined(t) ? Et.isUndefined(e) ? void 0 : n(void 0, e, 0, a) : n(e, t, 0, a) } function o(e, t) { if (!Et.isUndefined(t)) return n(void 0, t) } function r(e, t) { return Et.isUndefined(t) ? Et.isUndefined(e) ? void 0 : n(void 0, e) : n(void 0, t) } function s(i, a, o) { return o in t ? n(i, a) : o in e ? n(void 0, i) : void 0 } const d = { url: o, method: o, data: o, baseURL: r, transformRequest: r, transformResponse: r, paramsSerializer: r, timeout: r, timeoutMessage: r, withCredentials: r, withXSRFToken: r, adapter: r, responseType: r, xsrfCookieName: r, xsrfHeaderName: r, onUploadProgress: r, onDownloadProgress: r, decompress: r, maxContentLength: r, maxBodyLength: r, beforeRedirect: r, transport: r, httpAgent: r, httpsAgent: r, cancelToken: r, socketPath: r, responseEncoding: r, validateStatus: s, headers: (e, t, i) => a(mi(e), mi(t), 0, !0) }; return Et.forEach(Object.keys(Object.assign({}, e, t)), (function (n) { const o = d[n] || a, r = o(e[n], t[n], n); Et.isUndefined(r) && o !== s || (i[n] = r) })), i } const gi = e => { const t = fi({}, e); let i, { data: n, withXSRFToken: a, xsrfHeaderName: o, xsrfCookieName: r, headers: s, auth: d } = t; if (t.headers = s = ai.from(s), t.url = Dt(wi(t.baseURL, t.url), e.params, e.paramsSerializer), d && s.set("Authorization", "Basic " + btoa((d.username || "") + ":" + (d.password ? unescape(encodeURIComponent(d.password)) : ""))), Et.isFormData(n)) if (Qt.hasStandardBrowserEnv || Qt.hasStandardBrowserWebWorkerEnv) s.setContentType(void 0); else if (!1 !== (i = s.getContentType())) { const [e, ...t] = i ? i.split(";").map((e => e.trim())).filter(Boolean) : []; s.setContentType([e || "multipart/form-data", ...t].join("; ")) } if (Qt.hasStandardBrowserEnv && (a && Et.isFunction(a) && (a = a(t)), a || !1 !== a && pi(t.url))) { const e = o && r && hi.read(r); e && s.set(o, e) } return t }, Si = "undefined" != typeof XMLHttpRequest && function (e) { return new Promise((function (t, i) { const n = gi(e); let a = n.data; const o = ai.from(n.headers).normalize(); let r, s, d, c, u, { responseType: l, onUploadProgress: p, onDownloadProgress: h } = n; function w() { c && c(), u && u(), n.cancelToken && n.cancelToken.unsubscribe(r), n.signal && n.signal.removeEventListener("abort", r) } let m = new XMLHttpRequest; function f() { if (!m) return; const n = ai.from("getAllResponseHeaders" in m && m.getAllResponseHeaders()); di((function (e) { t(e), w() }), (function (e) { i(e), w() }), { data: l && "text" !== l && "json" !== l ? m.response : m.responseText, status: m.status, statusText: m.statusText, headers: n, config: e, request: m }), m = null } m.open(n.method.toUpperCase(), n.url, !0), m.timeout = n.timeout, "onloadend" in m ? m.onloadend = f : m.onreadystatechange = function () { m && 4 === m.readyState && (0 !== m.status || m.responseURL && 0 === m.responseURL.indexOf("file:")) && setTimeout(f) }, m.onabort = function () { m && (i(new Rt("Request aborted", Rt.ECONNABORTED, e, m)), m = null) }, m.onerror = function () { i(new Rt("Network Error", Rt.ERR_NETWORK, e, m)), m = null }, m.ontimeout = function () { let t = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded"; const a = n.transitional || jt; n.timeoutErrorMessage && (t = n.timeoutErrorMessage), i(new Rt(t, a.clarifyTimeoutError ? Rt.ETIMEDOUT : Rt.ECONNABORTED, e, m)), m = null }, void 0 === a && o.setContentType(null), "setRequestHeader" in m && Et.forEach(o.toJSON(), (function (e, t) { m.setRequestHeader(t, e) })), Et.isUndefined(n.withCredentials) || (m.withCredentials = !!n.withCredentials), l && "json" !== l && (m.responseType = n.responseType), h && ([d, u] = ci(h, !0), m.addEventListener("progress", d)), p && m.upload && ([s, c] = ci(p), m.upload.addEventListener("progress", s), m.upload.addEventListener("loadend", c)), (n.cancelToken || n.signal) && (r = t => { m && (i(!t || t.type ? new si(null, e, m) : t), m.abort(), m = null) }, n.cancelToken && n.cancelToken.subscribe(r), n.signal && (n.signal.aborted ? r() : n.signal.addEventListener("abort", r))); const g = function (e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" }(n.url); g && -1 === Qt.protocols.indexOf(g) ? i(new Rt("Unsupported protocol " + g + ":", Rt.ERR_BAD_REQUEST, e)) : m.send(a || null) })) }, yi = (e, t) => { const { length: i } = e = e ? e.filter(Boolean) : []; if (t || i) { let i, n = new AbortController; const a = function (e) { if (!i) { i = !0, r(); const t = e instanceof Error ? e : this.reason; n.abort(t instanceof Rt ? t : new si(t instanceof Error ? t.message : t)) } }; let o = t && setTimeout((() => { o = null, a(new Rt(`timeout ${t} of ms exceeded`, Rt.ETIMEDOUT)) }), t); const r = () => { e && (o && clearTimeout(o), o = null, e.forEach((e => { e.unsubscribe ? e.unsubscribe(a) : e.removeEventListener("abort", a) })), e = null) }; e.forEach((e => e.addEventListener("abort", a))); const { signal: s } = n; return s.unsubscribe = () => Et.asap(r), s } }, bi = function* (e, t) { let i = e.byteLength; if (!t || i < t) return void (yield e); let n, a = 0; for (; a < i;)n = a + t, yield e.slice(a, n), a = n }, _i = async function* (e) { if (e[Symbol.asyncIterator]) return void (yield* e); const t = e.getReader(); try { for (; ;) { const { done: e, value: i } = await t.read(); if (e) break; yield i } } finally { await t.cancel() } }, Wi = (e, t, i, n) => { const a = async function* (e, t) { for await (const i of _i(e)) yield* bi(i, t) }(e, t); let o, r = 0, s = e => { o || (o = !0, n && n(e)) }; return new ReadableStream({ async pull(e) { try { const { done: t, value: n } = await a.next(); if (t) return s(), void e.close(); let o = n.byteLength; if (i) { let e = r += o; i(e) } e.enqueue(new Uint8Array(n)) } catch (t) { throw s(t), t } }, cancel: e => (s(e), a.return()) }, { highWaterMark: 2 }) }, Ai = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response, vi = Ai && "function" == typeof ReadableStream, Ci = Ai && ("function" == typeof TextEncoder ? (e => t => e.encode(t))(new TextEncoder) : async e => new Uint8Array(await new Response(e).arrayBuffer())), Mi = (e, ...t) => { try { return !!e(...t) } catch (i) { return !1 } }, Pi = vi && Mi((() => { let e = !1; const t = new Request(Qt.origin, { body: new ReadableStream, method: "POST", get duplex() { return e = !0, "half" } }).headers.has("Content-Type"); return e && !t })), Ei = vi && Mi((() => Et.isReadableStream(new Response("").body))), Ri = { stream: Ei && (e => e.body) }; var Oi; Ai && (Oi = new Response, ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e => { !Ri[e] && (Ri[e] = Et.isFunction(Oi[e]) ? t => t[e]() : (t, i) => { throw new Rt(`Response type '${e}' is not supported`, Rt.ERR_NOT_SUPPORT, i) }) }))); const ki = async (e, t) => { const i = Et.toFiniteNumber(e.getContentLength()); return null == i ? (async e => { if (null == e) return 0; if (Et.isBlob(e)) return e.size; if (Et.isSpecCompliantForm(e)) { const t = new Request(Qt.origin, { method: "POST", body: e }); return (await t.arrayBuffer()).byteLength } return Et.isArrayBufferView(e) || Et.isArrayBuffer(e) ? e.byteLength : (Et.isURLSearchParams(e) && (e += ""), Et.isString(e) ? (await Ci(e)).byteLength : void 0) })(t) : i }, Ti = { http: null, xhr: Si, fetch: Ai && (async e => { let { url: t, method: i, data: n, signal: a, cancelToken: o, timeout: r, onDownloadProgress: s, onUploadProgress: d, responseType: c, headers: u, withCredentials: l = "same-origin", fetchOptions: p } = gi(e); c = c ? (c + "").toLowerCase() : "text"; let h, w = yi([a, o && o.toAbortSignal()], r); const m = w && w.unsubscribe && (() => { w.unsubscribe() }); let f; try { if (d && Pi && "get" !== i && "head" !== i && 0 !== (f = await ki(u, n))) { let e, i = new Request(t, { method: "POST", body: n, duplex: "half" }); if (Et.isFormData(n) && (e = i.headers.get("content-type")) && u.setContentType(e), i.body) { const [e, t] = ui(f, ci(li(d))); n = Wi(i.body, 65536, e, t) } } Et.isString(l) || (l = l ? "include" : "omit"); const a = "credentials" in Request.prototype; h = new Request(t, { ...p, signal: w, method: i.toUpperCase(), headers: u.normalize().toJSON(), body: n, duplex: "half", credentials: a ? l : void 0 }); let o = await fetch(h); const r = Ei && ("stream" === c || "response" === c); if (Ei && (s || r && m)) { const e = {};["status", "statusText", "headers"].forEach((t => { e[t] = o[t] })); const t = Et.toFiniteNumber(o.headers.get("content-length")), [i, n] = s && ui(t, ci(li(s), !0)) || []; o = new Response(Wi(o.body, 65536, i, (() => { n && n(), m && m() })), e) } c = c || "text"; let g = await Ri[Et.findKey(Ri, c) || "text"](o, e); return !r && m && m(), await new Promise(((t, i) => { di(t, i, { data: g, headers: ai.from(o.headers), status: o.status, statusText: o.statusText, config: e, request: h }) })) } catch (g) { if (m && m(), g && "TypeError" === g.name && /fetch/i.test(g.message)) throw Object.assign(new Rt("Network Error", Rt.ERR_NETWORK, e, h), { cause: g.cause || g }); throw Rt.from(g, g && g.code, e, h) } }) }; Et.forEach(Ti, ((e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch (i) { } Object.defineProperty(e, "adapterName", { value: t }) } })); const Li = e => `- ${e}`, xi = e => Et.isFunction(e) || null === e || !1 === e, Ii = e => { e = Et.isArray(e) ? e : [e]; const { length: t } = e; let i, n; const a = {}; for (let o = 0; o < t; o++) { let t; if (i = e[o], n = i, !xi(i) && (n = Ti[(t = String(i)).toLowerCase()], void 0 === n)) throw new Rt(`Unknown adapter '${t}'`); if (n) break; a[t || "#" + o] = n } if (!n) { const e = Object.entries(a).map((([e, t]) => `adapter ${e} ` + (!1 === t ? "is not supported by the environment" : "is not available in the build"))); throw new Rt("There is no suitable adapter to dispatch the request " + (t ? e.length > 1 ? "since :\n" + e.map(Li).join("\n") : " " + Li(e[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT") } return n }; function Fi(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new si(null, e) } function Ni(e) { Fi(e), e.headers = ai.from(e.headers), e.data = oi.call(e, e.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1); return Ii(e.adapter || Yt.adapter)(e).then((function (t) { return Fi(e), t.data = oi.call(e, e.transformResponse, t), t.headers = ai.from(t.headers), t }), (function (t) { return ri(t) || (Fi(e), t && t.response && (t.response.data = oi.call(e, e.transformResponse, t.response), t.response.headers = ai.from(t.response.headers))), Promise.reject(t) })) } const Ui = "1.7.9", Bi = {};["object", "boolean", "number", "function", "string", "symbol"].forEach(((e, t) => { Bi[e] = function (i) { return typeof i === e || "a" + (t < 1 ? "n " : " ") + e } })); const qi = {}; Bi.transitional = function (e, t, i) { function n(e, t) { return "[Axios v1.7.9] Transitional option '" + e + "'" + t + (i ? ". " + i : "") } return (i, a, o) => { if (!1 === e) throw new Rt(n(a, " has been removed" + (t ? " in " + t : "")), Rt.ERR_DEPRECATED); return t && !qi[a] && (qi[a] = !0, console.warn(n(a, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(i, a, o) } }, Bi.spelling = function (e) { return (t, i) => (console.warn(`${i} is likely a misspelling of ${e}`), !0) }; const Di = { assertOptions: function (e, t, i) { if ("object" != typeof e) throw new Rt("options must be an object", Rt.ERR_BAD_OPTION_VALUE); const n = Object.keys(e); let a = n.length; for (; a-- > 0;) { const o = n[a], r = t[o]; if (r) { const t = e[o], i = void 0 === t || r(t, o, e); if (!0 !== i) throw new Rt("option " + o + " must be " + i, Rt.ERR_BAD_OPTION_VALUE) } else if (!0 !== i) throw new Rt("Unknown option " + o, Rt.ERR_BAD_OPTION) } }, validators: Bi }, Ji = Di.validators; class ji { constructor(e) { this.defaults = e, this.interceptors = { request: new Jt, response: new Jt } } async request(e, t) { try { return await this._request(e, t) } catch (i) { if (i instanceof Error) { let e = {}; Error.captureStackTrace ? Error.captureStackTrace(e) : e = new Error; const t = e.stack ? e.stack.replace(/^.+\n/, "") : ""; try { i.stack ? t && !String(i.stack).endsWith(t.replace(/^.+\n.+\n/, "")) && (i.stack += "\n" + t) : i.stack = t } catch (n) { } } throw i } } _request(e, t) { "string" == typeof e ? (t = t || {}).url = e : t = e || {}, t = fi(this.defaults, t); const { transitional: i, paramsSerializer: n, headers: a } = t; void 0 !== i && Di.assertOptions(i, { silentJSONParsing: Ji.transitional(Ji.boolean), forcedJSONParsing: Ji.transitional(Ji.boolean), clarifyTimeoutError: Ji.transitional(Ji.boolean) }, !1), null != n && (Et.isFunction(n) ? t.paramsSerializer = { serialize: n } : Di.assertOptions(n, { encode: Ji.function, serialize: Ji.function }, !0)), Di.assertOptions(t, { baseUrl: Ji.spelling("baseURL"), withXsrfToken: Ji.spelling("withXSRFToken") }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase(); let o = a && Et.merge(a.common, a[t.method]); a && Et.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e => { delete a[e] })), t.headers = ai.concat(o, a); const r = []; let s = !0; this.interceptors.request.forEach((function (e) { "function" == typeof e.runWhen && !1 === e.runWhen(t) || (s = s && e.synchronous, r.unshift(e.fulfilled, e.rejected)) })); const d = []; let c; this.interceptors.response.forEach((function (e) { d.push(e.fulfilled, e.rejected) })); let u, l = 0; if (!s) { const e = [Ni.bind(this), void 0]; for (e.unshift.apply(e, r), e.push.apply(e, d), u = e.length, c = Promise.resolve(t); l < u;)c = c.then(e[l++], e[l++]); return c } u = r.length; let p = t; for (l = 0; l < u;) { const e = r[l++], t = r[l++]; try { p = e(p) } catch (h) { t.call(this, h); break } } try { c = Ni.call(this, p) } catch (h) { return Promise.reject(h) } for (l = 0, u = d.length; l < u;)c = c.then(d[l++], d[l++]); return c } getUri(e) { return Dt(wi((e = fi(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer) } } Et.forEach(["delete", "get", "head", "options"], (function (e) { ji.prototype[e] = function (t, i) { return this.request(fi(i || {}, { method: e, url: t, data: (i || {}).data })) } })), Et.forEach(["post", "put", "patch"], (function (e) { function t(t) { return function (i, n, a) { return this.request(fi(a || {}, { method: e, headers: t ? { "Content-Type": "multipart/form-data" } : {}, url: i, data: n })) } } ji.prototype[e] = t(), ji.prototype[e + "Form"] = t(!0) })); class zi { constructor(e) { if ("function" != typeof e) throw new TypeError("executor must be a function."); let t; this.promise = new Promise((function (e) { t = e })); const i = this; this.promise.then((e => { if (!i._listeners) return; let t = i._listeners.length; for (; t-- > 0;)i._listeners[t](e); i._listeners = null })), this.promise.then = e => { let t; const n = new Promise((e => { i.subscribe(e), t = e })).then(e); return n.cancel = function () { i.unsubscribe(t) }, n }, e((function (e, n, a) { i.reason || (i.reason = new si(e, n, a), t(i.reason)) })) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(e) { this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e] } unsubscribe(e) { if (!this._listeners) return; const t = this._listeners.indexOf(e); -1 !== t && this._listeners.splice(t, 1) } toAbortSignal() { const e = new AbortController, t = t => { e.abort(t) }; return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal } static source() { let e; return { token: new zi((function (t) { e = t })), cancel: e } } } const Gi = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(Gi).forEach((([e, t]) => { Gi[t] = e })); const Vi = function e(t) { const i = new ji(t), n = qe(ji.prototype.request, i); return Et.extend(n, ji.prototype, i, { allOwnKeys: !0 }), Et.extend(n, i, null, { allOwnKeys: !0 }), n.create = function (i) { return e(fi(t, i)) }, n }(Yt); function Ki() { chrome.runtime.onMessage.addListener((function (e, t, i) { if ("request_from_injected_script" === e.channelName) { switch (e.data.action) { case "fetchData": !async function (e, t) { var i, n; Fe("handling fetch data request", e); const a = (await Re(["access_token"])).access_token; let o, r = 0; do { try { const i = await Vi({ url: e.data.url, data: e.data.body, method: e.data.method, headers: { Authorization: `Bearer ${a || ""}` } }); return i.data.token && await Oe({ access_token: i.data.token }), t(i), void Fe("Data fetched sucessfully", i) } catch (s) { if (o = s.JSON ? s.JSON() : s, 500 !== (null == (i = o.response) ? void 0 : i.status) && 503 !== (null == (n = o.response) ? void 0 : n.status) && "ERR_NETWORK" != o.code) break; r++, await Le(1e3 * r) } } while (e.data.retryLimit && r < e.data.retryLimit); t(o), Fe("Data fetch failed", o) }(e.data, i); break; case "upload_contact_list": console.log("message.data", e.data.data.body), async function ({ data: e, sendResponse: t }) { const { chunks: i, reportId: n } = e; console.log("chunks", i), console.log("reportId", n), console.log(`Processing ${i.length} chunks in background...`); const a = (await Re(["access_token"])).access_token; for (let s = 0; s < i.length; s++) { const e = i[s]; try { console.log(`Processing chunk ${s + 1}/${i.length}`), console.log("chunk and reportId", e, n); const r = await Vi.post(`${o}/upload-contact-list`, { contactList: e, reportId: n }, { headers: { Authorization: `Bearer ${a || ""}` } }); if (console.log("response", r), !r.data) throw new Error(`HTTP error! status: ${r.data}`); const d = await r.data; if (console.log(`Chunk ${s + 1} uploaded successfully:`, d), t({ success: !0 }), s < i.length - 1) { const e = Math.floor(2e3 * Math.random()) + 3e3; console.log(`Waiting ${e}ms before next chunk...`), await new Promise((t => setTimeout(t, e))) } } catch (r) { console.error(`Background chunk ${s + 1} upload failed:`, r) } } console.log("All background chunks processed") }({ data: { chunks: e.data.data.body.contactList, reportId: e.data.data.body.reportId }, sendResponse: i }); break; case "storage": !async function (e, t) { if (Fe("handling storage request", e), e.get) { const i = await Re(e.get); t(i), Fe("Data extracted from storage", i) } else e.set && (await Oe(e.set), t(!0), Fe("Data Stored in storage", e.set)) }(e.data, i); break; case "logout": Fe("logout: removing token"), ke("access_token"); break; case "screenLock": !async function (e, t) { var i, n; Fe("handling screen lock request", e), e.data.freeScreen ? null == (i = chrome.power) || i.releaseKeepAwake() : null == (n = chrome.power) || n.requestKeepAwake("display"); t(!0) }(e.data, i) }return !0 } })) } Vi.Axios = ji, Vi.CanceledError = si, Vi.CancelToken = zi, Vi.isCancel = ri, Vi.VERSION = Ui, Vi.toFormData = Ft, Vi.AxiosError = Rt, Vi.Cancel = Vi.CanceledError, Vi.all = function (e) { return Promise.all(e) }, Vi.spread = function (e) { return function (t) { return e.apply(null, t) } }, Vi.isAxiosError = function (e) { return Et.isObject(e) && !0 === e.isAxiosError }, Vi.mergeConfig = fi, Vi.AxiosHeaders = ai, Vi.formToJSON = e => Xt(Et.isHTMLForm(e) ? new FormData(e) : e), Vi.getAdapter = Ii, Vi.HttpStatusCode = Gi, Vi.default = Vi, chrome.runtime.onMessage.addListener(((e, t, i) => { var o, r, s; try { if (a("save_token")(e)) Fe("saving token"), e.payload.token && Oe({ access_token: e.payload.token }).then((() => { Fe("token saved") })); else if (a("logout")(e)) Fe("logout: removing token"), ke("access_token").then((() => { Fe("token removed") })); else if (a("WA_content_script_loaded")(e)) { const i = null == (o = t.tab) ? void 0 : o.id; Fe("WhatsApp content script loded, saving tab id", i, e), Oe({ active_sheetwa_tab_id: i }) } else a("open_extension_from_worker")(e) ? (Fe("open extension", e), ve(`${n}?ext=1`)) : a("close_inactive_wa_tab")(e) && (Fe("close inactive wa tab", e), (null == (r = t.tab) ? void 0 : r.id) && Ue({ activeWATabID: null == (s = t.tab) ? void 0 : s.id })) } catch (d) { Fe("error when handling msg listener", d) } })), Ki(), Be(), chrome.action.onClicked.addListener((async e => { const t = String(e.url).startsWith(n), i = (await Re(["active_sheetwa_tab_id"])).active_sheetwa_tab_id; let a = await Ue({ activeWATabID: t ? e.id : i, makeLastTabActive: !0 }); a ? a == i || (await Ee(a), await Ne()) : (a = (await ve(n)).id, await Ne()), await Pe(a); try { const e = await Te(a, { type: "open_extension", payload: null }); if ((o = "open_extension", e => e.type === o)(e)) return } catch (r) { } var o; Fe("Relaoding whatsapp tab"), Ee(a), await Ne(), Te(a, { type: "open_extension", payload: null }) })), function () { const e = "launch_sheetwa"; chrome.runtime.onInstalled.addListener((function () { chrome.contextMenus.create({ id: e, title: "SheeWA", documentUrlPatterns: ["*://web.whatsapp.com/*"] }) })), chrome.contextMenus.onClicked.addListener(((t, i) => { t.menuItemId == e && chrome.tabs.query({ active: !0, currentWindow: !0 }, (e => { e.length > 0 && e[0].id && Te(e[0].id, { type: "open_extension", payload: null }) })) })) }(), async function () { await Oe({ lib_path: chrome.runtime.getURL("lib.js") }) }() }();
